{"id":"nuoc-03s","title":"[Entity-07] Implement invocation queuing when lock held","description":"## Micro-task\nQueue invocations waiting for lock on virtual object.\n\n## Acceptance\n- [ ] Invocation queued in order\n- [ ] Dequeued when lock released\n- [ ] FIFO ordering","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:12.823867131-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.780597887-06:00","dependencies":[{"issue_id":"nuoc-03s","depends_on_id":"nuoc-bdj","type":"blocks","created_at":"2026-01-28T07:06:57.056734091-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-04t","title":"[Lifecycle-08] Implement running → suspended transition","description":"## Micro-task\nHandler suspends waiting for dependencies.\n\n## Acceptance\n- [ ] Status updated to suspended\n- [ ] Suspension reason recorded\n- [ ] Worker slot freed","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.56494421-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.485118636-06:00","dependencies":[{"issue_id":"nuoc-04t","depends_on_id":"nuoc-lz7","type":"blocks","created_at":"2026-01-28T07:07:02.505889727-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-0cb","title":"[HTTP-09] Implement /send endpoint (fire-and-forget)","description":"## Micro-task\nPOST /{target}/send returns immediately.\n\n## Response\n{invocationId: \"inv_...\", status: \"Accepted\"}\n\n## Acceptance\n- [ ] Returns immediately\n- [ ] Invocation ID returned\n- [ ] Handler executes async","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:20.848219344-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.352213762-06:00","dependencies":[{"issue_id":"nuoc-0cb","depends_on_id":"nuoc-ph8","type":"blocks","created_at":"2026-01-28T07:07:00.971203781-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-0pi","title":"[Ctx-10] Implement ctx.sleep for durable delays","description":"## Micro-task\nImplement ctx.sleep(duration) for crash-safe sleeps.\n\n## Acceptance\n- [ ] Task suspends for duration\n- [ ] Survives crash and resumes correctly\n- [ ] Journaled for replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:22.018959685-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.598992767-06:00","dependencies":[{"issue_id":"nuoc-0pi","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:58.518284043-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-0v2","title":"Build ratatui TUI dashboard for workflow engine observability and control","description":"## KIRK: Key Intent\nBuild a terminal UI using ratatui (Rust) that provides real-time observability into the workflow engine. Covers job list, task DAG visualization, event timeline, metrics, and manual controls (cancel, retry, approve awakeables). This is the equivalent of Temporal's Web UI and Hatchet's dashboard, but native to the terminal.\n\n## EARS\n- WHEN the TUI starts, THE SYSTEM SHALL connect to the SQLite journal and display a live-updating job list with status indicators.\n- WHILE viewing a job, THE SYSTEM SHALL render the task DAG as a graph with nodes colored by status (green=COMPLETED, red=FAILED, yellow=RUNNING, gray=PENDING, blue=SUSPENDED).\n- WHEN a task status changes in the DB, THE SYSTEM SHALL update the TUI within 1 second.\n- WHERE manual controls are available, THE SYSTEM SHALL provide keyboard shortcuts for: cancel job (c), retry job (r), resolve awakeable (a), view event log (e).\n- IF awakeables are pending, THE SYSTEM SHALL show them in a dedicated panel with resolve action.\n\n## BDD Scenarios\n```gherkin\nFeature: TUI Dashboard\n\n  Scenario: Job list view\n    Given 5 jobs exist in various states\n    When the TUI opens\n    Then all 5 jobs are listed with status, progress (N/M tasks), and timing\n    And jobs are sorted by position then created_at\n\n  Scenario: DAG view for selected job\n    Given job \"tdd15-bead-abc\" has 16 tasks with dependencies\n    When user selects that job and presses Enter\n    Then a DAG graph renders showing task nodes and dependency edges\n    And each node is colored by current status\n\n  Scenario: Live update\n    Given TUI is showing job \"tdd15-bead-abc\"\n    When task \"green\" transitions from RUNNING to COMPLETED\n    Then the DAG node for \"green\" changes from yellow to green within 1s\n\n  Scenario: Cancel via keyboard\n    Given job \"tdd15-bead-abc\" is RUNNING\n    When user presses 'c' and confirms\n    Then job-cancel is called and status updates to CANCELLED\n\n  Scenario: Resolve awakeable\n    Given awakeable \"awk-123\" is PENDING for task \"verify\"\n    When user presses 'a', selects \"awk-123\", types \"APPROVED\", presses Enter\n    Then the awakeable is resolved with payload \"APPROVED\"\n\n  Scenario: Event log timeline\n    Given job has 30 events\n    When user presses 'e'\n    Then events are shown in reverse chronological order with type, task, and timestamp\n\n  Scenario: Metrics panel\n    Given 10 jobs have completed\n    When user views metrics\n    Then they see: avg duration per phase, retry rate, regression frequency, gate pass rate\n```\n\n## ATDD\n1. TUI binary: `oc-tui` or `cargo run --bin oc-tui`\n2. Reads directly from SQLite journal (no separate API needed initially)\n3. DAG layout algorithm handles the 16-node TDD15 graph correctly\n4. Keyboard navigation: arrow keys for list, tab for panels, q to quit\n5. Color scheme works on both dark and light terminals\n6. Responsive to terminal resize\n\n## DBC\n- **Precondition**: SQLite journal exists at .oc-workflow/journal.db\n- **Postcondition**: All displayed data matches current DB state within 1s\n- **Invariant**: TUI is read-only for display, write-only through explicit user actions (cancel, retry, resolve)\n\n## Architecture\n- Rust binary using ratatui + crossterm\n- Reads SQLite via rusqlite\n- Panels: JobList | DAGView | EventLog | Metrics | Awakeables\n- File watcher or 500ms poll on journal.db for live updates\n- DAG layout: topological sort → layer assignment → minimize edge crossings (Sugiyama-style)\n- Command dispatch: TUI writes to journal via oc-engine commands (shell out to nu or direct SQL)\n\n## Screens\n1. **Main**: Split — left panel job list, right panel selected job DAG\n2. **Event Log**: Full-screen event timeline for selected job\n3. **Metrics**: Dashboard with histograms and counters\n4. **Awakeables**: List of pending awakeables with resolve action\n5. **Help**: Keyboard shortcut reference (press ?)","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:27.597690747-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.721750691-06:00","dependencies":[{"issue_id":"nuoc-0v2","depends_on_id":"nuoc-7mg","type":"blocks","created_at":"2026-01-28T02:38:58.501219217-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-0v2","depends_on_id":"nuoc-rvh","type":"blocks","created_at":"2026-01-28T02:38:58.519361411-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-0v2","depends_on_id":"nuoc-1y2","type":"blocks","created_at":"2026-01-28T06:34:09.586674419-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-0vc","title":"[Replay-15] Add replay stats tracking (replayed vs executed counts)","description":"## Micro-task\nTrack how many operations were replayed vs newly executed for observability.\n\n## Deliverable\n- $env.REPLAY_COUNT incremented on replay\n- $env.EXECUTE_COUNT incremented on live execution\n- Logged at task completion\n\n## Acceptance\n- [ ] Counts tracked during execution\n- [ ] Visible in job-status output\n- [ ] Useful for debugging replay issues","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:08.295783559-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.926141243-06:00","dependencies":[{"issue_id":"nuoc-0vc","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:54.191725546-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-0zq","title":"Parameterize all SQL queries to eliminate injection surface","description":"## KIRK: Key Intent\nEliminate SQL injection vectors in oc-engine.nu where user-controlled strings (job IDs, task names, bead IDs) flow into SQL via string interpolation.\n\n## EARS (Easy Approach to Requirements Syntax)\n- WHEN a job_id, task_name, or bead_id contains SQL metacharacters (e.g. `'; DROP TABLE jobs;--`), THEN the engine SHALL reject the input with an error before any SQL execution.\n- WHILE the engine is constructing any SQL query, THE SYSTEM SHALL use parameterized queries or validated identifiers, never raw string interpolation of external inputs.\n- WHERE `sql-escape` is used today, IT SHALL be replaced with either sqlite3 parameterized binding or a strict allowlist validator (`^[a-zA-Z0-9_.-]+$`).\n\n## BDD Scenarios\n```gherkin\nFeature: SQL injection prevention\n\n  Scenario: Malicious job ID rejected at creation\n    Given a job definition with name \"test'; DROP TABLE jobs;--\"\n    When job-create is called\n    Then an error is raised with message containing \"invalid identifier\"\n    And no SQL is executed\n\n  Scenario: Valid job ID accepted\n    Given a job definition with name \"tdd15-beads-abc123\"\n    When job-create is called\n    Then the job is created successfully\n\n  Scenario: Unicode and special chars rejected\n    Given a job definition with name \"job—with–dashes\"\n    When job-create is called\n    Then an error is raised with message containing \"invalid identifier\"\n```\n\n## ATDD Acceptance Tests\n1. Fuzz test: Generate 100 random strings with SQL metacharacters, confirm all are rejected by the validator\n2. Every public export in oc-engine.nu that takes a string ID parameter validates it before SQL use\n3. grep for raw string interpolation in SQL contexts returns zero matches after fix\n\n## DBC (Design by Contract)\n- **Precondition**: All ID parameters (job_id, task_name, bead_id, var) match `^[a-zA-Z0-9_.-]+$`\n- **Postcondition**: No SQL query contains unescaped external input\n- **Invariant**: The `sql` and `sql-exec` helpers never receive interpolated user strings; they receive parameterized or pre-validated values\n\n## Files\n- oc-engine.nu:93-128 (sql, sql-exec, sql-escape, emit-event)\n- oc-engine.nu:134-169 (job-create)\n- oc-engine.nu:259-331 (task-execute)","status":"closed","priority":0,"issue_type":"bug","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:21:52.063506528-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:45:36.129034746-06:00","closed_at":"2026-01-29T06:45:36.129037026-06:00"}
{"id":"nuoc-12h","title":"[TUI-10] Implement event log view","description":"## Micro-task\nFull-screen event log for selected job.\n\n## Acceptance\n- [ ] Events in reverse chronological order\n- [ ] Event type, task, timestamp shown\n- [ ] Scrollable list\n- [ ] 'e' key toggles view","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:30.779068602-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.168106972-06:00","dependencies":[{"issue_id":"nuoc-12h","depends_on_id":"nuoc-xma","type":"blocks","created_at":"2026-01-28T07:07:06.656879549-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1eb","title":"[Proto-12] Implement processing phase in stream","description":"## Micro-task\nHandle new journal entries during processing.\n\n## Acceptance\n- [ ] New entries from handler received\n- [ ] CompletionMessages sent for completables\n- [ ] EntryAckMessages sent if REQUIRES_ACK","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:25.35727587-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.307288037-06:00","dependencies":[{"issue_id":"nuoc-1eb","depends_on_id":"nuoc-eep","type":"blocks","created_at":"2026-01-28T07:06:59.249509541-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1eq","title":"Implement workflow versioning for safe deployment of definition changes","description":"## KIRK: Key Intent\nEnable deploying new workflow definitions while in-flight executions continue on their original version. Prevents non-determinism errors when workflow code changes between execution and replay. Modeled after Temporal's worker versioning and patching API.\n\n## EARS\n- WHEN a job is created, THE SYSTEM SHALL record the workflow_version (content hash of the job definition).\n- WHEN a job resumes, THE SYSTEM SHALL replay using the workflow version that created it, not the current version.\n- IF a workflow definition changes, THE SYSTEM SHALL assign a new version hash and new jobs use the new version.\n- WHERE a version migration is needed, THE SYSTEM SHALL support a patch mechanism to bridge old and new versions.\n\n## BDD Scenarios\n```gherkin\nFeature: Workflow versioning\n\n  Scenario: Old job resumes with old definition\n    Given job J was created with workflow version V1\n    And workflow definition is updated to V2\n    When job-resume is called for J\n    Then J replays using V1 definition\n\n  Scenario: New job uses new definition\n    Given workflow version is V2\n    When a new job is created\n    Then it uses V2\n\n  Scenario: Version mismatch detected\n    Given job J uses V1 but V1 definition is no longer available\n    When job-resume is called\n    Then an error is raised: \"workflow version V1 not found\"\n```\n\n## ATDD\n1. workflow_version column in jobs table, populated on creation\n2. Version is content hash of job definition record\n3. Old versions retained until all jobs using them complete\n4. Version lookup on resume returns correct definition\n\n## DBC\n- **Precondition**: Job definition is hashable and immutable once recorded\n- **Postcondition**: A resumed job always uses its creation-time definition\n- **Invariant**: No job replays against a different version than it was created with\n\n## Files\n- oc-engine.nu:10-26 (jobs schema — add workflow_version)\n- oc-engine.nu:134-169 (job-create — compute and store version)\n- oc-engine.nu:244-256 (job-resume — lookup version)","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:34.949838071-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.097938183-06:00","dependencies":[{"issue_id":"nuoc-1eq","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.329612245-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1n4","title":"[Entity-09] Implement workflow run deduplication","description":"## Micro-task\nEnsure workflow run handler executes exactly once per ID.\n\n## Acceptance\n- [ ] Second run returns cached result\n- [ ] No re-execution\n- [ ] Concurrent runs deduplicated","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:14.751195567-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.747882215-06:00","dependencies":[{"issue_id":"nuoc-1n4","depends_on_id":"nuoc-1zd","type":"blocks","created_at":"2026-01-28T07:06:57.077595129-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1y2","title":"Implement streaming/real-time task output","description":"## KIRK: Key Intent\nStream task output in real-time as it's produced, rather than waiting for completion. Essential for LLM agent sessions where users want to see progress. Modeled after Hatchet's streaming.\n\n## EARS\n- WHEN a task produces incremental output, THE SYSTEM SHALL publish it to a stream associated with the task.\n- WHERE a client subscribes to a task's stream, THE SYSTEM SHALL deliver output chunks in order.\n- IF a client disconnects and reconnects, THE SYSTEM SHALL replay from the last acknowledged offset.\n- WHEN a task completes, THE SYSTEM SHALL close the stream and mark it as complete.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Streaming output\n\n  Scenario: Real-time LLM output\n    Given agent task T is generating text\n    When T produces chunks [\"Hello\", \" world\", \"!\"]\n    Then subscribers receive chunks in order\n    And TUI shows incremental output\n\n  Scenario: Late subscriber catches up\n    Given task T already produced [\"A\", \"B\", \"C\"]\n    When client subscribes at offset 0\n    Then client receives A, B, C, then live updates\n\n  Scenario: Stream survives disconnect\n    Given client received offset 2\n    When client disconnects and reconnects with offset=2\n    Then client continues from chunk 3\n\\`\\`\\`\n\n## ATDD\n1. Stream storage in SQLite with offset tracking\n2. SSE or WebSocket endpoint for subscriptions\n3. Backpressure handling for slow consumers\n4. TUI integration for live agent output\n\n## DBC\n- **Precondition**: Task supports streaming output\n- **Postcondition**: All chunks delivered in order to subscribers\n- **Invariant**: No chunk lost; replay possible from any offset\n\n## Schema Addition\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS output_streams (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  chunk_index INTEGER NOT NULL,\n  content TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  UNIQUE (job_id, task_name, chunk_index)\n);\n\\`\\`\\`","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.754278224-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.958794186-06:00","dependencies":[{"issue_id":"nuoc-1y2","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T06:34:09.492002235-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1yc","title":"[Ctx-16] Implement ctx.rand.uuidv4 for deterministic UUID","description":"## Micro-task\nImplement ctx.rand.uuidv4() for deterministic UUID generation.\n\n## Acceptance\n- [ ] Returns valid v4 UUID\n- [ ] Deterministic based on seed\n- [ ] Same UUID on replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:34.576131311-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.503661373-06:00","dependencies":[{"issue_id":"nuoc-1yc","depends_on_id":"nuoc-8gu","type":"blocks","created_at":"2026-01-28T07:07:06.446150829-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-1zd","title":"[Entity-08] Create workflow_runs table","description":"## Micro-task\nSchema to track workflow run handler executions.\n\n## Deliverable\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS workflow_runs (\n  workflow_name TEXT NOT NULL,\n  workflow_id TEXT NOT NULL,\n  run_invocation_id TEXT,\n  status TEXT NOT NULL DEFAULT 'pending',\n  result TEXT,\n  PRIMARY KEY (workflow_name, workflow_id)\n);\n\\`\\`\\`\n\n## Acceptance\n- [ ] Table created\n- [ ] Exactly one run per workflow_id\n- [ ] Result stored on completion","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:13.957107094-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.764646895-06:00"}
{"id":"nuoc-20c","title":"Implement durable timers and sleep as first-class primitives","description":"## KIRK: Key Intent\nWorkflows need to sleep/delay durably — surviving crashes and resuming at the correct time. Timers are journaled and managed by the engine, not the worker. Modeled after Temporal's timers and Restate's sleep.\n\n## EARS\n- WHEN a task calls ctx.sleep(duration), THE SYSTEM SHALL journal the timer, suspend the task, and resume after duration elapses.\n- IF the engine crashes during a timer, THE SYSTEM SHALL restore the timer on recovery and resume at the correct time.\n- WHERE a timer's wake_at has passed during downtime, THE SYSTEM SHALL resume immediately on recovery.\n- WHEN a timer is cancelled, THE SYSTEM SHALL mark it cancelled and not wake the task.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Durable timers\n\n  Scenario: Sleep survives crash\n    Given task T calls ctx.sleep(300s) at T0\n    And engine crashes at T0+100s\n    When engine restarts at T0+200s\n    Then timer is restored with 100s remaining\n    At T0+300s task T resumes\n\n  Scenario: Timer already elapsed\n    Given task T sleeping until T0+60s\n    And engine down from T0+30s to T0+120s\n    When engine restarts\n    Then T resumes immediately\n\n  Scenario: Timer cancellation\n    Given task T sleeping with timer ID tmr-123\n    When cancel-timer tmr-123 is called\n    Then T receives cancellation error\n    And timer marked CANCELLED\n\\`\\`\\`\n\n## ATDD\n1. ctx.sleep(duration) and ctx.sleep_until(timestamp) APIs\n2. Timers persisted in dedicated table with wake_at\n3. Timer scheduler checks every 1s for due timers\n4. Timer state visible in job-status\n\n## DBC\n- **Precondition**: Duration \u003e 0 or timestamp in future\n- **Postcondition**: Task resumes at or after wake_at\n- **Invariant**: Timer fires exactly once (no double-wake)\n\n## Schema Addition\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS timers (\n  id TEXT PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  wake_at TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'SCHEDULED',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  fired_at TEXT\n);\n\\`\\`\\`","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:47.470040608-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.603255734-06:00","dependencies":[{"issue_id":"nuoc-20c","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.250186209-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-20c","depends_on_id":"nuoc-rvh","type":"blocks","created_at":"2026-01-28T06:34:09.435178789-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-235","title":"Implement Service Invocation Protocol — bidirectional message stream","description":"## KIRK: Key Intent\nImplement Restate's exact Service Invocation Protocol — a bidirectional message stream between engine and handlers. This is the wire protocol that makes durable execution work. Messages have 64-bit headers with type, flags, and length.\n\n## EARS\n- WHEN a handler is invoked, THE SYSTEM SHALL establish a bidirectional stream and send a StartMessage with invocation ID, known_entries, state_map, and random_seed.\n- WHEN the handler produces journal entries, THE SYSTEM SHALL send CompletionMessages with entry_index and result.\n- WHEN the handler suspends, IT SHALL send a SuspensionMessage with entry_indexes it's waiting on.\n- WHEN the handler completes, IT SHALL send an EndMessage (success) or ErrorMessage (failure).\n- WHERE REQUIRES_ACK flag is set, THE SYSTEM SHALL send EntryAckMessage after persisting.\n\n## Message Types (exact Restate codes)\n\\`\\`\\`\nRuntime → Handler:\n  0x0000 StartMessage       - Initialize invocation\n  0x8000 CompletionMessage  - Complete journal entry\n  0x8001 EntryAckMessage    - Acknowledge persistence\n\nHandler → Runtime:\n  0x0001 SuspensionMessage  - Suspend with awaited entries\n  0x0002 ErrorMessage       - Invocation failure\n  0x0003 EndMessage         - Successful completion\n\\`\\`\\`\n\n## Message Header Format (64-bit)\n\\`\\`\\`\nBits 0-15:  Message type (u16, big-endian)\nBits 16-31: Flags\n  - Bit 31: REQUIRES_ACK\n  - Bit 8:  COMPLETED (entry already done)\nBits 32-63: Payload length (u32, big-endian)\n\\`\\`\\`\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Service Invocation Protocol\n\n  Scenario: Full invocation lifecycle\n    Given handler \"greet\" is registered\n    When invocation starts\n    Then StartMessage sent with id, known_entries=0, state_map\n    When handler calls ctx.run()\n    Then RunCommandMessage journaled\n    And CompletionMessage sent with result\n    When handler returns\n    Then EndMessage sent\n\n  Scenario: Replay with known entries\n    Given invocation has 5 journaled entries\n    When handler reconnects after crash\n    Then StartMessage sent with known_entries=5\n    And entries 0-4 sent for replay\n    And handler resumes from entry 5\n\n  Scenario: Suspension on awakeable\n    Given handler calls ctx.awakeable()\n    When awaiting the promise\n    Then SuspensionMessage sent with [entry_index]\n    When awakeable resolved externally\n    Then CompletionMessage sent for that entry\n    And handler resumes\n\\`\\`\\`\n\n## ATDD\n1. Message serialization matches Restate's exact binary format\n2. StartMessage includes random_seed for deterministic RNG\n3. Suspension correctly lists all awaited entry indexes\n4. Error messages include code, message, related_entry_index\n\n## DBC\n- **Precondition**: Stream established before any messages\n- **Postcondition**: Stream terminates with exactly one of: EndMessage, ErrorMessage, or open SuspensionMessage\n- **Invariant**: Entry indexes are monotonically increasing within a stream\n\n## Implementation\nFor nushell: Use HTTP/1.1 request-response or implement over Unix sockets/named pipes. The protocol can be JSON-serialized for nushell ergonomics while maintaining Restate's exact semantics.","status":"closed","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:52.166233715-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:50:00.975979278-06:00","closed_at":"2026-01-29T06:50:00.975979278-06:00","close_reason":"Complete - Implemented Service Invocation Protocol with all message types, serialization, and validation"}
{"id":"nuoc-26t","title":"Implement complete Context API — ctx.run, ctx.rand, ctx.call, ctx.send, etc.","description":"## KIRK: Key Intent\nImplement Restate's complete Context API as nushell commands. Every method available in Restate's SDK should have an equivalent.\n\n## Context Methods (complete list)\n\n### State Management (ObjectContext only)\n- **ctx.get(key)**: Get state value\n- **ctx.set(key, value)**: Set state value\n- **ctx.clear(key)**: Delete state key\n- **ctx.clearAll()**: Delete all state\n- **ctx.stateKeys()**: List all keys\n\n### Communication\n- **ctx.call(target, handler, input)**: Sync invocation (blocks)\n- **ctx.send(target, handler, input, delay?)**: Async fire-and-forget\n- **ctx.sendDelayed(target, handler, input, delay)**: Scheduled send\n\n### Durable Execution\n- **ctx.run(fn)**: Execute side effect, journal result\n- **ctx.sleep(duration)**: Durable sleep\n- **ctx.sleepUntil(timestamp)**: Sleep until specific time\n\n### External Coordination\n- **ctx.awakeable()**: Create awakeable, returns {id, promise}\n- **ctx.resolveAwakeable(id, value)**: Resolve awakeable\n- **ctx.rejectAwakeable(id, error)**: Reject awakeable\n\n### Promises (Workflows)\n- **ctx.promise(key)**: Get/create durable promise\n- **ctx.peek(key)**: Non-blocking promise check\n- **ctx.complete(key, value)**: Resolve promise\n\n### Invocation Management\n- **ctx.cancel(invocationId)**: Cooperative cancellation\n- **ctx.attach(invocationId)**: Attach to invocation\n- **ctx.getOutput(invocationId)**: Get invocation result\n- **ctx.invocationId()**: Get current invocation ID\n\n### Determinism\n- **ctx.rand()**: Deterministic RNG using random_seed\n- **ctx.rand.uuidv4()**: Deterministic UUID\n\n## EARS\n- WHEN ctx.run() is called, THE SYSTEM SHALL execute the closure and journal the result.\n- WHEN ctx.run() replays, THE SYSTEM SHALL return journaled result without re-executing.\n- WHEN ctx.rand() is called, THE SYSTEM SHALL use random_seed from StartMessage for deterministic output.\n- WHEN ctx.call() is invoked, THE SYSTEM SHALL create CallCommandMessage and block until completion.\n- WHEN ctx.send() is invoked, THE SYSTEM SHALL create OneWayCallCommandMessage and return immediately.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Context API\n\n  Scenario: ctx.run journals side effect\n    Given handler calls ctx.run(() =\u003e http.get(url))\n    When http returns {data: 123}\n    Then journal entry created with output={data: 123}\n    On replay: {data: 123} returned, no HTTP call\n\n  Scenario: ctx.rand is deterministic\n    Given StartMessage with random_seed=42\n    When handler calls ctx.rand() twice\n    Then same values produced on every replay\n\n  Scenario: ctx.call vs ctx.send\n    Given handler calls ctx.call(svc, fn, input)\n    Then handler blocks until svc.fn completes\n    Given handler calls ctx.send(svc, fn, input)\n    Then handler continues immediately\n    And svc.fn executes asynchronously\n\n  Scenario: ctx.sleep durable\n    Given handler calls ctx.sleep(60s)\n    And engine crashes at 30s\n    When engine restarts\n    Then handler resumes at 60s (not 90s)\n\\`\\`\\`\n\n## Nushell Implementation\n\\`\\`\\`nu\n# Each ctx method is a nushell command that:\n# 1. Creates appropriate journal entry\n# 2. Checks for replay (return cached if exists)\n# 3. Executes operation\n# 4. Records result\n# 5. Returns result\n\nexport def \"ctx run\" [closure: closure] {\n  let entry_index = (next-entry-index)\n  let cached = (check-replay $entry_index \"run\")\n  if $cached != null { return $cached }\n  let result = (do $closure)\n  journal-write $entry_index \"run\" $result\n  $result\n}\n\\`\\`\\`\n\n## ATDD\n1. All ctx methods implemented as nushell commands\n2. Each method creates correct journal entry type\n3. Replay returns cached results\n4. Deterministic operations produce same output on replay\n\n## DBC\n- **Precondition**: Context is active (invocation running)\n- **Postcondition**: Operation journaled before returning\n- **Invariant**: ctx.run cannot nest (no ctx calls inside closure)","status":"open","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:59:00.247860381-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.681764269-06:00"}
{"id":"nuoc-280","title":"[HTTP-12] Implement idempotency cache cleanup","description":"## Micro-task\nPeriodically remove expired cache entries.\n\n## Acceptance\n- [ ] Runs every hour\n- [ ] Deletes where expires_at \u003c now\n- [ ] Doesn't block requests","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:23.815345796-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.270424568-06:00","dependencies":[{"issue_id":"nuoc-280","depends_on_id":"nuoc-99c","type":"blocks","created_at":"2026-01-28T07:07:01.031539662-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-2d6","title":"[Replay-03] Implement journal-read command to fetch entries for replay","description":"## Micro-task\nCreate nushell command to read all journal entries for a task attempt.\n\n## Deliverable\n\\`\\`\\`nu\nexport def journal-read [\n  job_id: string,\n  task_name: string,\n  attempt: int\n]: nothing -\u003e table {\n  sql \\$\"SELECT * FROM journal WHERE job_id='(\\$job_id)' AND task_name='(\\$task_name)' AND attempt=(\\$attempt) ORDER BY entry_index\"\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Returns entries in entry_index order\n- [ ] Empty table if no entries\n- [ ] Handles SQL escaping","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:03.484029622-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.224006686-06:00","dependencies":[{"issue_id":"nuoc-2d6","depends_on_id":"nuoc-m8e","type":"blocks","created_at":"2026-01-28T07:06:53.948396998-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-2qz","title":"Implement continue-as-new for workflow history compaction","description":"## KIRK: Key Intent\nLong-running workflows accumulate history that grows unbounded. Continue-as-new resets the workflow with fresh history while preserving logical continuity. Essential for infinite loops, recurring tasks, and avoiding memory pressure. Modeled after Temporal's continue-as-new.\n\n## EARS\n- WHEN a workflow calls continue_as_new(input), THE SYSTEM SHALL complete the current job and spawn a new job with fresh history.\n- WHERE continue-as-new is invoked, THE SYSTEM SHALL transfer only the provided input, not the full state.\n- IF a workflow's history exceeds a threshold (e.g., 10k events), THE SYSTEM SHALL warn or auto-trigger continue-as-new.\n- WHEN continue-as-new creates the successor job, THE SYSTEM SHALL link them via continuation_of field.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Continue-as-new\n\n  Scenario: Manual continue-as-new\n    Given job J1 has processed 5000 events\n    When task calls ctx.continue_as_new({batch: 101})\n    Then J1 completes with status CONTINUED\n    And J2 is created with input {batch: 101} and empty history\n    And J2.continuation_of = J1.id\n\n  Scenario: Auto continue-as-new on threshold\n    Given job history reaches 10000 events\n    When next task completes\n    Then warning is logged\n    And workflow may auto-continue based on config\n\n  Scenario: Continuation chain queryable\n    Given J1 -\u003e J2 -\u003e J3 via continue-as-new\n    When querying J3's lineage\n    Then response shows [J1, J2, J3]\n\\`\\`\\`\n\n## ATDD\n1. ctx.continue_as_new(input) API\n2. CONTINUED status distinct from COMPLETED\n3. continuation_of field links jobs\n4. History size visible in job-status\n\n## DBC\n- **Precondition**: Workflow is in RUNNING state\n- **Postcondition**: Current job CONTINUED, successor job PENDING\n- **Invariant**: No data loss — input explicitly transferred\n\n## Schema Addition\n\\`\\`\\`sql\nALTER TABLE jobs ADD COLUMN continuation_of TEXT REFERENCES jobs(id);\nALTER TABLE jobs ADD COLUMN history_size INTEGER DEFAULT 0;\n\\`\\`\\`","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:46.743708651-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.924782487-06:00","dependencies":[{"issue_id":"nuoc-2qz","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.30650483-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-2xg","title":"[Ctx-22] Implement ctx.getOutput for non-blocking result check","description":"## Micro-task\nImplement ctx.getOutput(invocationId) for non-blocking result retrieval.\n\n## Acceptance\n- [ ] Returns result if completed\n- [ ] Returns null if pending\n- [ ] Never blocks","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:04.063656456-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.175783111-06:00"}
{"id":"nuoc-37v","title":"[TUI-01] Set up Rust project with ratatui and crossterm","description":"## Micro-task\nInitialize Rust binary project with ratatui TUI framework.\n\n## Deliverable\n- Cargo.toml with dependencies\n- Basic main.rs with terminal setup\n- Event loop skeleton\n\n## Acceptance\n- [ ] cargo build succeeds\n- [ ] Terminal enters raw mode\n- [ ] Clean exit on 'q'","status":"closed","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:17.353180084-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:02:33.044429245-06:00","closed_at":"2026-01-29T05:02:33.044429245-06:00","close_reason":"Complete - Rust TUI project with ratatui/crossterm, all tests passing"}
{"id":"nuoc-3cd","title":"Wire phase-prompt dispatcher into run-task so TDD15 prompts are actually used","description":"## KIRK: Key Intent\nThe rich per-phase prompts in oc-tdd15.nu (prompt-triage, prompt-red, etc.) are never called. run-task uses build-prompt which produces a generic stub. The entire prompt engineering layer is dead code.\n\n## EARS\n- WHEN run-task dispatches an agent task, THE SYSTEM SHALL resolve task.run_cmd against the phase-prompt dispatcher in oc-tdd15.nu to produce the agent prompt.\n- WHERE a task has agent_type set, THE SYSTEM SHALL pass all prior task outputs (keyed by var) to the prompt builder.\n- IF run_cmd does not match any known phase, THEN the engine SHALL raise an error rather than send a generic prompt.\n\n## BDD Scenarios\n```gherkin\nFeature: Phase prompts dispatched correctly\n\n  Scenario: RED phase uses prompt-red\n    Given a task with run_cmd \"phase-4-red\" and agent_type \"general-purpose\"\n    When run-task executes the task\n    Then the prompt sent to opencode contains \"Phase 4: RED\"\n    And the prompt contains prior triage output\n\n  Scenario: Unknown phase rejected\n    Given a task with run_cmd \"phase-99-unknown\"\n    When run-task executes the task\n    Then an error is raised with message containing \"Unknown phase\"\n\n  Scenario: Prior outputs threaded through\n    Given task \"green\" depends on \"red\" which produced output \"test code here\"\n    When run-task executes \"green\"\n    Then the prompt contains \"test code here\" in the prior context section\n```\n\n## ATDD\n1. For each of the 16 TDD15 phases, verify the correct prompt-* function is called\n2. Verify prior_outputs record contains all completed task vars\n3. No task sends the generic build-prompt output to an agent\n\n## DBC\n- **Precondition**: task.run_cmd is a non-empty string matching a registered phase name\n- **Postcondition**: The prompt sent to the agent session was produced by the corresponding prompt-* function\n- **Invariant**: build-prompt is removed or only used as fallback for non-agent inline tasks\n\n## Files\n- oc-engine.nu:334-376 (run-task, build-prompt)\n- oc-tdd15.nu:171-461 (all prompt-* functions and phase-prompt dispatcher)","status":"closed","priority":0,"issue_type":"bug","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:22:35.555263114-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:43:53.173742542-06:00","closed_at":"2026-01-29T06:43:53.173744852-06:00"}
{"id":"nuoc-3efn","title":"[Worker-12] Implement fair distribution across workers","description":"## Micro-task\nRound-robin or least-loaded distribution.\n\n## Acceptance\n- [ ] Tasks distributed fairly\n- [ ] No worker overloaded\n- [ ] Verified with multi-worker test","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.097201588-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.834937005-06:00","dependencies":[{"issue_id":"nuoc-3efn","depends_on_id":"nuoc-4w4f","type":"blocks","created_at":"2026-01-28T07:07:02.751278376-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-3h1","title":"[HTTP-01] Set up HTTP server with configurable port","description":"## Micro-task\nCreate nushell HTTP server listening on port.\n\n## Acceptance\n- [ ] Server starts on configured port (default 8080)\n- [ ] Handles incoming connections\n- [ ] Clean shutdown on signal","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:12.050641088-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.518741295-06:00"}
{"id":"nuoc-3ja","title":"Implement activity heartbeats for long-running task progress tracking","description":"## KIRK: Key Intent\nLong-running tasks (LLM agent sessions, builds, deployments) need heartbeat mechanisms to report progress and detect stalls. If heartbeats stop, the task is considered failed and can be retried. Modeled after Temporal's activity heartbeats.\n\n## EARS\n- WHEN a task is configured with heartbeat_timeout_sec, THE SYSTEM SHALL expect heartbeat signals at intervals shorter than the timeout.\n- IF no heartbeat is received within heartbeat_timeout_sec, THE SYSTEM SHALL mark the task as FAILED with reason \"heartbeat timeout\" and trigger retry.\n- WHERE a task sends a heartbeat, IT MAY include progress data (percentage, current step, etc.) which is persisted and visible via status queries.\n- WHEN a task retries after heartbeat timeout, THE SYSTEM SHALL provide the last heartbeat progress data so the task can resume from that point.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Activity heartbeats\n\n  Scenario: Heartbeat keeps task alive\n    Given task T has heartbeat_timeout_sec=30\n    When T sends heartbeat every 10s\n    Then T remains RUNNING\n\n  Scenario: Missing heartbeat fails task\n    Given task T has heartbeat_timeout_sec=30\n    When T sends no heartbeat for 35s\n    Then T is marked FAILED with \"heartbeat timeout\"\n    And retry is triggered\n\n  Scenario: Progress data persisted\n    Given task T sends heartbeat with {progress: 50, step: \"compiling\"}\n    When status is queried\n    Then heartbeat_data shows {progress: 50, step: \"compiling\"}\n\n  Scenario: Retry receives last progress\n    Given task T failed at heartbeat with {progress: 75}\n    When T retries\n    Then T receives last_heartbeat_data = {progress: 75}\n\\`\\`\\`\n\n## ATDD\n1. Heartbeat reaper runs every 5s checking for stale tasks\n2. Progress data visible in job-status output\n3. Retry context includes last heartbeat data\n4. Agent tasks can call ctx.heartbeat(data) during execution\n\n## DBC\n- **Precondition**: heartbeat_timeout_sec \u003e 0 for heartbeat-enabled tasks\n- **Postcondition**: Task fails within 2x heartbeat_timeout_sec of last heartbeat\n- **Invariant**: Heartbeat data is append-only per task attempt","notes":"## Schema Addition\n```sql\n-- Heartbeat tracking for long-running tasks\nALTER TABLE tasks ADD COLUMN heartbeat_timeout_sec INTEGER;\nALTER TABLE tasks ADD COLUMN last_heartbeat_at TEXT;\nALTER TABLE tasks ADD COLUMN heartbeat_data TEXT;\n\nCREATE TABLE IF NOT EXISTS heartbeats (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  attempt INTEGER NOT NULL,\n  data TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\nCREATE INDEX idx_heartbeat_task ON heartbeats(job_id, task_name, attempt);\n```","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.12373843-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.654819111-06:00","dependencies":[{"issue_id":"nuoc-3ja","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T06:34:09.453766521-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-3ze","title":"[Lifecycle-06] Implement scheduled → ready transition","description":"## Micro-task\nScheduler checks for due scheduled invocations.\n\n## Acceptance\n- [ ] Runs periodically (every 1s)\n- [ ] Finds scheduled_start_at \u003c= now\n- [ ] Transitions to ready","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.523217394-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.51726144-06:00","dependencies":[{"issue_id":"nuoc-3ze","depends_on_id":"nuoc-w5m","type":"blocks","created_at":"2026-01-28T07:07:02.465424035-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-43v","title":"[Proto-02] Define message header struct","description":"## Micro-task\n64-bit header with type, flags, length.\n\n## Format\n- Bits 0-15: message type\n- Bits 16-31: flags (REQUIRES_ACK, COMPLETED)\n- Bits 32-63: payload length\n\n## Acceptance\n- [ ] Header serialization\n- [ ] Header deserialization\n- [ ] Big-endian byte order","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:12.687616959-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:09:44.773994298-06:00","closed_at":"2026-01-29T05:09:44.773996058-06:00","dependencies":[{"issue_id":"nuoc-43v","depends_on_id":"nuoc-8ax","type":"blocks","created_at":"2026-01-28T07:06:59.047470471-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-46w","title":"[Entity-11] Route invocation based on entity type","description":"## Micro-task\nDispatch invocation differently based on entity type.\n\n## Acceptance\n- [ ] Service: execute immediately\n- [ ] Virtual Object: acquire lock first\n- [ ] Workflow run: check deduplication first","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:16.965639631-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.715161862-06:00","dependencies":[{"issue_id":"nuoc-46w","depends_on_id":"nuoc-feh","type":"blocks","created_at":"2026-01-28T07:06:57.120385232-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-46w","depends_on_id":"nuoc-03s","type":"blocks","created_at":"2026-01-28T07:07:02.277408334-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-46w","depends_on_id":"nuoc-1n4","type":"blocks","created_at":"2026-01-28T07:07:02.299027104-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-4cr","title":"[TUI-08] Implement DAG layout algorithm","description":"## Micro-task\nCompute DAG layout for task graph visualization.\n\n## Algorithm\n1. Topological sort\n2. Layer assignment (Sugiyama)\n3. Node positioning\n4. Edge routing\n\n## Acceptance\n- [ ] Nodes placed in layers\n- [ ] No node overlaps\n- [ ] Edges drawn between deps","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:28.286138419-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.205919391-06:00","dependencies":[{"issue_id":"nuoc-4cr","depends_on_id":"nuoc-ks6","type":"blocks","created_at":"2026-01-28T07:07:06.615897053-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-4o8","title":"[Ctx-19] Implement ctx.complete for promise resolution","description":"## Micro-task\nImplement ctx.complete(key, value) to resolve promise.\n\n## Acceptance\n- [ ] Promise marked completed\n- [ ] All waiters resumed with value\n- [ ] Journaled","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:01:59.917647654-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.614852328-06:00","dependencies":[{"issue_id":"nuoc-4o8","depends_on_id":"nuoc-ie1","type":"blocks","created_at":"2026-01-28T07:07:02.285082382-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-4v3","title":"[TUI-12] Implement awakeable panel","description":"## Micro-task\nList pending awakeables with resolve action.\n\n## Acceptance\n- [ ] Pending awakeables listed\n- [ ] Select awakeable with arrows\n- [ ] 'a' opens resolve dialog","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:33.670193689-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.132480997-06:00","dependencies":[{"issue_id":"nuoc-4v3","depends_on_id":"nuoc-xma","type":"blocks","created_at":"2026-01-28T07:07:06.707185632-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-4w4f","title":"[Worker-06] Implement task claiming (atomic)","description":"## Micro-task\nWorker atomically claims a task from queue.\n\n## SQL\n```sql\nUPDATE task_queues \nSET status='CLAIMED', claimed_by=?, claimed_at=datetime('now')\nWHERE id = (SELECT id FROM task_queues WHERE queue_name=? AND status='QUEUED' LIMIT 1)\n```\n\n## Acceptance\n- [ ] Atomic claim (no double dispatch)\n- [ ] Returns task details\n- [ ] Updates active_slots","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.972529934-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.934060949-06:00","dependencies":[{"issue_id":"nuoc-4w4f","depends_on_id":"nuoc-m5uj","type":"blocks","created_at":"2026-01-28T07:07:02.603027975-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-4w4f","depends_on_id":"nuoc-pciq","type":"blocks","created_at":"2026-01-28T07:07:02.623030074-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-577","title":"Implement deterministic replay from journal — Restate/Temporal core primitive","description":"## KIRK: Key Intent\nTransform the events table from an audit log into the authoritative source of truth. On resume, reconstruct state by replaying the journal — returning stored results for completed operations instead of re-executing them. This is THE foundational primitive of durable execution.\n\n## EARS\n- WHEN a task operation (agent call, shell command, gate check) completes, THE SYSTEM SHALL persist the full input, output, and operation type as a journal entry before acknowledging completion.\n- WHEN job-resume reconstructs workflow state, THE SYSTEM SHALL replay journal entries in order, returning stored results for completed operations without re-executing them.\n- IF a journal entry exists for (job_id, task_name, attempt, operation_index), THEN replay SHALL return the stored result and skip execution.\n- WHERE workflow code is re-executed during replay, THE SYSTEM SHALL detect non-determinism by comparing generated commands against stored journal entries.\n\n## BDD Scenarios\n```gherkin\nFeature: Deterministic replay\n\n  Scenario: Crash recovery replays without re-execution\n    Given job J completed tasks A and B, then crashed during task C\n    And journal has entries for A.output=\"x\" and B.output=\"y\"\n    When job-resume is called\n    Then task A returns \"x\" from journal without calling run-task\n    And task B returns \"y\" from journal without calling run-task\n    And task C re-executes from scratch\n\n  Scenario: Side effect not repeated on replay\n    Given task A made an API call that was journaled with result R\n    When replay reaches task A\n    Then R is returned directly\n    And no API call is made\n\n  Scenario: Non-determinism detected\n    Given journal shows task A produced command \"call-agent\"\n    When replay of task A produces command \"run-shell\" instead\n    Then a non-determinism error is raised\n    And the job fails with diagnostic info\n```\n\n## ATDD\n1. Kill process mid-job, resume — end state identical to uninterrupted run\n2. Journal entries contain (job_id, task_name, attempt, op_index, op_type, input_hash, output)\n3. Replay counter: track how many operations were replayed vs re-executed per resume\n4. No external side effects occur during replay phase\n\n## DBC\n- **Precondition**: Journal is append-only and intact\n- **Postcondition**: Replayed state matches original execution state\n- **Invariant**: For any completed operation, journal entry exists; for any journal entry, replay produces identical result\n\n## Architecture Notes\n- Journal entry schema: (id, job_id, task_name, attempt, op_index, op_type, input_hash, output, created_at)\n- Replay mode flag on task-execute context: when true, read from journal; when false, execute and write\n- This is Restate's \"command-response\" pattern and Temporal's \"event sourcing\" model\n\n## Files\n- oc-engine.nu:69-78 (events schema — redesign as journal)\n- oc-engine.nu:259-331 (task-execute — add replay path)\n- oc-engine.nu:244-256 (job-resume — implement replay)\n- oc-engine.nu:334-376 (run-task — journal writes)","notes":"## Schema Addition\n```sql\n-- Redesign events table as authoritative journal\nDROP TABLE IF EXISTS events;\nCREATE TABLE IF NOT EXISTS journal (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  attempt INTEGER NOT NULL DEFAULT 1,\n  op_index INTEGER NOT NULL,\n  op_type TEXT NOT NULL,\n  input_hash TEXT,\n  input TEXT,\n  output TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  UNIQUE (job_id, task_name, attempt, op_index)\n);\nCREATE INDEX idx_journal_replay ON journal(job_id, task_name, attempt);\n```\n\n## Additional Edge Case Scenarios\n```gherkin\n  Scenario: Partial journal corruption detected\n    Given journal has entries 1-5 for task A\n    And entry 3 is corrupted (checksum mismatch)\n    When replay is attempted\n    Then error 'journal corruption at op_index 3' is raised\n    And job is marked FAILED with corruption flag\n\n  Scenario: Concurrent replay attempts rejected\n    Given job J is being replayed by process P1\n    When process P2 attempts to replay J\n    Then P2 receives 'job locked for replay' error\n    And P1 continues unaffected\n\n  Scenario: Replay with schema migration\n    Given journal was written with schema v1\n    And current engine uses schema v2\n    When replay is attempted\n    Then migration adapter converts v1 entries to v2 format\n    And replay succeeds\n\n  Scenario: Large output truncation and recovery\n    Given task output exceeds 10MB\n    When journaling\n    Then output is chunked into multiple entries\n    When replaying\n    Then chunks are reassembled correctly\n```","status":"closed","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:36:27.218697503-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:55:29.446781733-06:00","closed_at":"2026-01-29T06:55:29.446783913-06:00"}
{"id":"nuoc-5cz","title":"[Replay-11] Add replay verification to ctx.sleep","description":"## Micro-task\nctx.sleep verifies duration matches during replay.\n\n## Acceptance\n- [ ] Replayed ctx.sleep returns immediately with cached completion\n- [ ] Non-determinism detected if duration differs","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:02.421178156-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.289030812-06:00","dependencies":[{"issue_id":"nuoc-5cz","depends_on_id":"nuoc-c0k","type":"blocks","created_at":"2026-01-28T07:06:54.110992532-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-5uu","title":"[Ctx-08] Implement ctx.sendDelayed for scheduled sends","description":"## Micro-task\nImplement ctx.sendDelayed(target, handler, input, delay) for delayed invocations.\n\n## Acceptance\n- [ ] Invocation scheduled for now + delay\n- [ ] Returns invocation_id\n- [ ] Journaled for replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:19.439533448-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.649519798-06:00","dependencies":[{"issue_id":"nuoc-5uu","depends_on_id":"nuoc-qll","type":"blocks","created_at":"2026-01-28T07:06:57.139170335-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-5w8","title":"[Entity-14] Validate handler exists on invocation","description":"## Micro-task\nCheck that handler exists in entity definition before executing.\n\n## Acceptance\n- [ ] Error if handler not found\n- [ ] Clear error message\n- [ ] Fast lookup","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:20.578531555-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.63158188-06:00","dependencies":[{"issue_id":"nuoc-5w8","depends_on_id":"nuoc-uuy","type":"blocks","created_at":"2026-01-28T07:07:02.363921031-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-60i","title":"Add regression cycle detection with max-regression cap","description":"## KIRK: Key Intent\nRegression loops (mf1 -\u003e refactor -\u003e fp_gates -\u003e green -\u003e ... -\u003e mf1) can cycle infinitely. Add cycle detection and a max regression counter.\n\n## EARS\n- WHEN a task triggers regression, THE SYSTEM SHALL increment a regression_count on the target task.\n- IF regression_count exceeds max_regressions (default 3), THEN the job SHALL fail with error \\\"regression limit exceeded for task X\\\".\n- WHILE regression is in progress, THE SYSTEM SHALL log the regression chain in the events table.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Bounded regression\n\n  Scenario: Regression under limit succeeds\n    Given task \\\"mf1\\\" fails and regresses to \\\"refactor\\\" for the 1st time\n    When task-regress is called\n    Then \\\"refactor\\\" is reset to PENDING with regression_count = 1\n\n  Scenario: Regression over limit fails job\n    Given task \\\"mf1\\\" has regressed to \\\"refactor\\\" 3 times already\n    When mf1 fails again with regression\n    Then the job transitions to FAILED\n    And error contains \\\"regression limit exceeded\\\"\n\n  Scenario: Different regression targets tracked independently\n    Given task \\\"fp_gates\\\" regresses to \\\"green\\\" 2 times\n    And task \\\"mf1\\\" regresses to \\\"refactor\\\" 2 times\n    Then both are under their individual limits\n\\`\\`\\`\n\n## ATDD\n1. regression_count column exists in tasks table and increments correctly\n2. Job fails when any task exceeds max_regressions\n3. Event log shows full regression chain for debugging\n\n## DBC\n- **Precondition**: target task exists, max_regressions \u003e 0\n- **Postcondition**: regression_count \u003c= max_regressions for all tasks, or job is FAILED\n- **Invariant**: regression_count monotonically increases per task per job execution\n\n## Files\n- oc-engine.nu:10-26 (tasks schema — add regression_count, max_regressions columns)\n- oc-engine.nu:400-418 (task-regress)\n- oc-engine.nu:316-328 (regression trigger in task-execute)","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:23:53.799732158-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.756527558-06:00"}
{"id":"nuoc-66b","title":"[TUI-09] Render DAG view with task nodes","description":"## Micro-task\nDraw DAG with colored task nodes.\n\n## Acceptance\n- [ ] Nodes show task name\n- [ ] Nodes colored by status\n- [ ] Dependency edges visible\n- [ ] Selected node highlighted","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:29.304912481-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.188024014-06:00","dependencies":[{"issue_id":"nuoc-66b","depends_on_id":"nuoc-4cr","type":"blocks","created_at":"2026-01-28T07:07:06.637805329-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-6dd","title":"[Ctx-24] Add validation: no ctx.* calls inside ctx.run","description":"## Micro-task\nDetect and error if ctx.* is called inside ctx.run closure.\n\n## Acceptance\n- [ ] Error raised with clear message\n- [ ] Explains why nested calls forbidden\n- [ ] Checked at runtime","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:06.627039969-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.023286963-06:00"}
{"id":"nuoc-6dn","title":"[Ctx-14] Implement ctx.rejectAwakeable","description":"## Micro-task\nImplement ctx.rejectAwakeable(id, error) to complete awakeable with failure.\n\n## Acceptance\n- [ ] Awakeable marked rejected\n- [ ] Waiting task receives error\n- [ ] Journaled","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:32.377360371-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.5343371-06:00","dependencies":[{"issue_id":"nuoc-6dn","depends_on_id":"nuoc-d56","type":"blocks","created_at":"2026-01-28T07:06:59.59819732-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-6k0","title":"Implement concurrency control and rate limiting — Hatchet primitive","description":"## KIRK: Key Intent\nAdd concurrency keys, rate limiting, and fairness algorithms. Essential for LLM agent orchestration where API tokens, cost budgets, and provider rate limits must be respected. Modeled after Hatchet's concurrency strategies.\n\n## EARS\n- WHEN a task declares a concurrency_key, THE SYSTEM SHALL limit concurrent executions sharing that key to max_concurrent.\n- IF max_concurrent is reached for a key, THE SYSTEM SHALL queue new tasks for that key using the configured strategy (FIFO, CANCEL_IN_PROGRESS, CANCEL_NEWEST, GROUP_ROUND_ROBIN).\n- WHERE a task declares rate_limit with (limit, window_sec), THE SYSTEM SHALL enforce that no more than limit executions start within any rolling window of window_sec seconds for that rate limit key.\n- WHEN rate limit is exceeded, THE SYSTEM SHALL re-queue the task and retry after the window resets.\n\n## BDD Scenarios\n```gherkin\nFeature: Concurrency and rate limiting\n\n  Scenario: Concurrency key limits parallel execution\n    Given concurrency_key \"llm:sonnet\" with max_concurrent=2\n    And 2 tasks with that key are RUNNING\n    When a 3rd task with key \"llm:sonnet\" becomes ready\n    Then it remains QUEUED until one of the 2 completes\n\n  Scenario: Rate limit enforced\n    Given rate_limit \"openai\" with limit=10, window_sec=60\n    And 10 tasks started in the last 40 seconds\n    When an 11th task attempts to start\n    Then it is re-queued with next_eligible_at = earliest_start + 60s\n\n  Scenario: CANCEL_IN_PROGRESS strategy\n    Given concurrency_key \"chat:user-123\" with strategy CANCEL_IN_PROGRESS and max=1\n    And task T1 is running for that key\n    When task T2 arrives for key \"chat:user-123\"\n    Then T1 is cancelled and T2 starts\n\n  Scenario: GROUP_ROUND_ROBIN fairness\n    Given 3 tenants each with 5 queued tasks and max_concurrent=2 global\n    When tasks are dispatched\n    Then each tenant gets roughly equal execution time\n```\n\n## ATDD\n1. Concurrent task count for any key never exceeds max_concurrent\n2. Rate limit window correctly enforced (test with sub-second precision)\n3. Strategy selection (FIFO, CANCEL_IN_PROGRESS, etc.) configurable per task definition\n4. Metrics: queue depth per concurrency key, rate limit hits per window\n\n## DBC\n- **Precondition**: concurrency_key and rate_limit are optional task-level configs\n- **Postcondition**: Active count for key \u003c= max_concurrent at all times\n- **Invariant**: Rate limit window is never exceeded; tasks re-queued not dropped\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS concurrency_keys (\n  key TEXT PRIMARY KEY,\n  max_concurrent INTEGER NOT NULL DEFAULT 1,\n  strategy TEXT NOT NULL DEFAULT 'FIFO',\n  active_count INTEGER NOT NULL DEFAULT 0\n);\nCREATE TABLE IF NOT EXISTS rate_limits (\n  key TEXT PRIMARY KEY,\n  max_per_window INTEGER NOT NULL,\n  window_sec INTEGER NOT NULL,\n  current_count INTEGER NOT NULL DEFAULT 0,\n  window_start TEXT NOT NULL DEFAULT (datetime('now'))\n);\n```","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:40.54073684-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.671425301-06:00","dependencies":[{"issue_id":"nuoc-6k0","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T02:38:58.443018378-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-6nd","title":"[TUI-13] Implement resolve awakeable dialog","description":"## Micro-task\nModal dialog to resolve awakeable with payload.\n\n## Acceptance\n- [ ] Text input for payload\n- [ ] Enter confirms resolution\n- [ ] Esc cancels\n- [ ] Awakeable resolved in DB","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:35.072055144-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.115265098-06:00","dependencies":[{"issue_id":"nuoc-6nd","depends_on_id":"nuoc-4v3","type":"blocks","created_at":"2026-01-28T07:07:06.728817951-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-752","title":"[HTTP-05] Create idempotency_cache table","description":"## Micro-task\nSchema for caching idempotent responses.\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE idempotency_cache (\n  key_hash TEXT,\n  service_name TEXT,\n  handler_name TEXT,\n  invocation_id TEXT,\n  response BLOB,\n  created_at TEXT,\n  expires_at TEXT,\n  PRIMARY KEY (key_hash, service_name, handler_name)\n);\n\\`\\`\\`\n\n## Acceptance\n- [ ] Table created\n- [ ] Expiration indexed","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:16.005952237-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.450952547-06:00"}
{"id":"nuoc-76u","title":"Implement virtual objects with keyed state store — Restate primitive","description":"## KIRK: Key Intent\nAdd addressable stateful entities (virtual objects) with single-writer guarantees per key. State persists across invocations and is co-located with execution. Eliminates need for external state management.\n\n## EARS\n- WHEN a handler operates on a keyed entity, THE SYSTEM SHALL acquire an exclusive lock on that key, ensuring single-writer semantics.\n- WHILE a key is locked, THE SYSTEM SHALL queue subsequent operations on that key until the lock is released.\n- WHERE state is read or written via ctx.state_get/ctx.state_set, THE SYSTEM SHALL persist changes to a key-value store in SQLite, journaling each mutation.\n- IF the engine crashes, THE SYSTEM SHALL reconstruct keyed state from the journal on recovery.\n\n## BDD Scenarios\n```gherkin\nFeature: Virtual objects with keyed state\n\n  Scenario: State persists across invocations\n    Given virtual object \"bead:abc\" has state {phase: 4, attempts: 2}\n    When a new handler invocation reads state for key \"bead:abc\"\n    Then it receives {phase: 4, attempts: 2}\n\n  Scenario: Single-writer guarantee\n    Given handler H1 holds lock on key \"bead:abc\"\n    When handler H2 attempts to operate on \"bead:abc\"\n    Then H2 is queued until H1 completes\n\n  Scenario: State recovered from journal\n    Given key \"bead:abc\" had state {phase: 6} before crash\n    When engine restarts and replays journal\n    Then state for \"bead:abc\" is {phase: 6}\n```\n\n## ATDD\n1. Concurrent writes to same key are serialized (never interleaved)\n2. State survives engine restart via journal replay\n3. K/V operations are journaled and replayable\n4. Lock acquisition timeout prevents deadlocks\n\n## DBC\n- **Precondition**: Key is a non-empty string matching identifier pattern\n- **Postcondition**: After state_set(key, val), subsequent state_get(key) returns val\n- **Invariant**: At most one writer holds a key lock at any time\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS keyed_state (\n  key TEXT NOT NULL,\n  field TEXT NOT NULL,\n  value TEXT,\n  version INTEGER DEFAULT 0,\n  updated_at TEXT NOT NULL DEFAULT (datetime('now')),\n  PRIMARY KEY (key, field)\n);\nCREATE TABLE IF NOT EXISTS key_locks (\n  key TEXT PRIMARY KEY,\n  holder_task_id TEXT NOT NULL,\n  acquired_at TEXT NOT NULL DEFAULT (datetime('now')),\n  expires_at TEXT\n);\n```","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:36:27.239285346-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.738518041-06:00","dependencies":[{"issue_id":"nuoc-76u","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.286698532-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7g7","title":"Implement explicit saga compensation with LIFO unwind — Temporal primitive","description":"## KIRK: Key Intent\nReplace informal regression with explicit saga pattern. Each task optionally registers a compensating action before executing. On failure, compensations unwind in LIFO order. Modeled after Temporal's saga implementation.\n\n## EARS\n- WHEN a task defines a compensate action, THE SYSTEM SHALL register it in a compensation stack before executing the forward action.\n- IF a task fails and the job is configured for saga compensation, THE SYSTEM SHALL execute all registered compensations in reverse order (LIFO).\n- WHERE a compensation itself fails, THE SYSTEM SHALL log the failure and continue unwinding remaining compensations.\n- WHEN compensation completes, THE SYSTEM SHALL mark the job as COMPENSATED (distinct from FAILED).\n\n## BDD Scenarios\n```gherkin\nFeature: Saga compensation\n\n  Scenario: Forward steps compensated on failure\n    Given tasks [A, B, C] with compensations [undo-A, undo-B, undo-C]\n    And A and B completed successfully\n    When C fails\n    Then undo-B executes, then undo-A executes (LIFO)\n    And job status is COMPENSATED\n\n  Scenario: Compensation failure logged but unwind continues\n    Given tasks [A, B] with compensations [undo-A, undo-B]\n    When B fails and undo-B also fails\n    Then undo-B failure is logged\n    And undo-A still executes\n    And job status is COMPENSATION_FAILED\n\n  Scenario: No compensation defined — falls back to FAILED\n    Given task C has no compensate action\n    When C fails\n    Then job status is FAILED (no compensation attempted)\n\n  Scenario: Idempotent compensations\n    Given compensation undo-A ran once\n    When undo-A is retried due to crash recovery\n    Then it produces the same result (idempotent)\n```\n\n## ATDD\n1. Compensation stack persisted in journal (survives crash mid-compensation)\n2. LIFO order verified by event timestamps\n3. Compensation actions are idempotent (test by running twice)\n4. Regression (on_fail_regress) and saga can coexist — saga for cross-task, regression for intra-task\n\n## DBC\n- **Precondition**: Compensation action is a valid run_cmd or agent task\n- **Postcondition**: All registered compensations execute on saga failure, or their failures are logged\n- **Invariant**: Compensation stack order matches reverse registration order\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS compensations (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  compensate_cmd TEXT NOT NULL,\n  registered_at TEXT NOT NULL DEFAULT (datetime('now')),\n  status TEXT DEFAULT 'REGISTERED',\n  executed_at TEXT,\n  error TEXT\n);\n```","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:34.928659422-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.704182553-06:00","dependencies":[{"issue_id":"nuoc-7g7","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.387195812-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-7g7","depends_on_id":"nuoc-60i","type":"blocks","created_at":"2026-01-28T02:38:58.405496734-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7gk","title":"[TUI-05] Render job list panel with status colors","description":"## Micro-task\nRender job list with colored status indicators.\n\n## Colors\n- COMPLETED: green\n- FAILED: red\n- RUNNING: yellow\n- PENDING: gray\n- SUSPENDED: blue\n\n## Acceptance\n- [ ] Jobs displayed in list\n- [ ] Status colored correctly\n- [ ] Selected job highlighted","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:24.786767667-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.253768477-06:00","dependencies":[{"issue_id":"nuoc-7gk","depends_on_id":"nuoc-b9r","type":"blocks","created_at":"2026-01-28T07:07:06.550230794-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7mb","title":"[Ctx-01] Implement ctx.get for state retrieval","description":"## Micro-task\nImplement ctx.get(key) to retrieve state value for virtual objects.\n\n## Deliverable\n\\`\\`\\`nu\nexport def \"ctx get\" [key: string] {\n  let idx = (next-entry-index)\n  if $env.REPLAY_MODE and $idx \u003c $env.KNOWN_ENTRIES {\n    return (check-replay ... $idx)\n  }\n  let value = (sql $\"SELECT value FROM keyed_state WHERE key='($env.OBJECT_KEY)' AND field='($key)'\")\n  journal-write ... $idx \"get_state\" {key: $key} $value\n  $value\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Returns state value for key\n- [ ] Replays from journal\n- [ ] Null if key not exists","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.94409463-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.353142769-06:00","dependencies":[{"issue_id":"nuoc-7mb","depends_on_id":"nuoc-ufl","type":"blocks","created_at":"2026-01-28T07:06:56.086961892-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7mg","title":"Implement awakeables — durable promises resolvable by external systems","description":"## KIRK: Key Intent\nAdd durable promises (awakeables) that let workflows suspend and wait for external signals. Enables human-in-the-loop approval, webhook callbacks, and cross-workflow coordination. This replaces the auto-approving user_approval gate.\n\n## EARS\n- WHEN a task calls ctx.awakeable(), THE SYSTEM SHALL generate a unique awakeable ID, persist it in the journal, and suspend the task.\n- WHEN an external system calls resolve-awakeable with the ID and a payload, THE SYSTEM SHALL resume the suspended task with that payload.\n- IF the engine crashes while a task is suspended on an awakeable, THE SYSTEM SHALL restore the suspension state on recovery and continue waiting.\n- WHERE an awakeable has a timeout, THE SYSTEM SHALL fail the awakeable if not resolved within the timeout.\n\n## BDD Scenarios\n```gherkin\nFeature: Awakeables / external signals\n\n  Scenario: Human approval via awakeable\n    Given task \"verify\" creates awakeable with ID \"awk-123\"\n    And task suspends waiting for resolution\n    When user calls \"resolve-awakeable awk-123 --payload APPROVED\"\n    Then task \"verify\" resumes with input \"APPROVED\"\n    And gate evaluates the approval\n\n  Scenario: Webhook resolves awakeable\n    Given task \"deploy\" creates awakeable \"awk-456\" and sends ID to webhook URL\n    When the webhook callback hits /awakeables/awk-456/resolve with payload\n    Then the task resumes with the webhook payload\n\n  Scenario: Awakeable survives crash\n    Given task is suspended on awakeable \"awk-789\"\n    And engine crashes and restarts\n    When \"resolve-awakeable awk-789 --payload data\" is called\n    Then the task resumes correctly\n\n  Scenario: Awakeable timeout\n    Given awakeable \"awk-000\" has timeout 300s\n    When 300s pass without resolution\n    Then the awakeable fails with \"timeout\"\n    And the task receives a timeout error\n```\n\n## ATDD\n1. CLI command: `oc awakeable resolve \u003cid\u003e --payload \u003cdata\u003e`\n2. HTTP endpoint: POST /awakeables/:id/resolve\n3. Awakeable state persisted in journal, survives crash\n4. user_approval gate refactored to use awakeable instead of auto-approve\n\n## DBC\n- **Precondition**: Awakeable ID is unique and generated by the engine\n- **Postcondition**: Exactly one resolution per awakeable ID\n- **Invariant**: Suspended task consumes zero execution resources until resolved\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS awakeables (\n  id TEXT PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'PENDING',\n  payload TEXT,\n  timeout_at TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  resolved_at TEXT\n);\n```","notes":"Implemented awakeables with CLI commands, HTTP API, user_approval gate integration, timeout support, and full test coverage.\n\n**Added:**\n- oc-cli.nu: CLI tool with awakeable resolve/reject/list/show commands\n- oc-cli.nu: job status/list/cancel/retry commands\n- oc-cli.nu: system commands for timeout check and event log\n- Refactored user_approval gate to use awakeables instead of auto-approve\n- docs/awakeables.md: Comprehensive documentation with examples\n- tests/test-cli-awakeable.nu: CLI command tests\n- tests/test-user-approval-awakeable.nu: User approval gate tests\n\n**All ATDD requirements met:**\n1. ✅ CLI command: `oc awakeable resolve \u003cid\u003e --payload \u003cdata\u003e`\n2. ✅ HTTP endpoint: POST /awakeables/:id/resolve (already existed in oc-http-server.py)\n3. ✅ Awakeable state persisted in journal, survives crash\n4. ✅ user_approval gate refactored to use awakeable instead of auto-approve\n\n**All EARS requirements met:**\n- ✅ ctx.awakeable() generates unique ID and persists to journal\n- ✅ resolve-awakeable wakes suspended task with payload\n- ✅ Engine crash recovery restores suspension state\n- ✅ Timeout support with automatic failure\n\nAll tests passing.","status":"closed","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:36:27.259573832-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T07:04:19.916006315-06:00","closed_at":"2026-01-29T07:04:19.916009495-06:00","dependencies":[{"issue_id":"nuoc-7mg","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.424090903-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7t1","title":"[HTTP-11] Implement /output endpoint (peek)","description":"## Micro-task\nGET /output returns result if ready.\n\n## Responses\n- {message: \"not ready\"} if pending\n- {result: ...} if completed\n- {message: \"not found\"} if no invocation\n\n## Acceptance\n- [ ] Non-blocking\n- [ ] Correct status returned","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:22.772846176-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.303758388-06:00","dependencies":[{"issue_id":"nuoc-7t1","depends_on_id":"nuoc-ph8","type":"blocks","created_at":"2026-01-28T07:07:01.011546744-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-7wmq","title":"[Awk-04] Implement awakeable creation in ctx.awakeable","description":"## Micro-task\nCreate awakeable record and return ID.\n\n## Acceptance\n- [ ] Record inserted\n- [ ] ID returned\n- [ ] Journaled for replay","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.857630319-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:00:24.715732092-06:00","closed_at":"2026-01-28T23:00:24.715732092-06:00","close_reason":"TDD15 complete - ctx-awakeable implemented and tested","dependencies":[{"issue_id":"nuoc-7wmq","depends_on_id":"nuoc-pvb2","type":"blocks","created_at":"2026-01-28T07:07:04.386613836-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8ax","title":"[Proto-01] Define message type constants","description":"## Micro-task\nDefine message type codes as Restate specifies.\n\n## Constants\n```nu\nconst MSG_START = 0x0000\nconst MSG_COMPLETION = 0x8000\nconst MSG_ENTRY_ACK = 0x8001\nconst MSG_SUSPENSION = 0x0001\nconst MSG_ERROR = 0x0002\nconst MSG_END = 0x0003\n```\n\n## Acceptance\n- [ ] All message types defined\n- [ ] Matches Restate spec exactly","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:11.836749958-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.488154129-06:00"}
{"id":"nuoc-8gu","title":"[Ctx-15] Implement ctx.rand for deterministic RNG","description":"## Micro-task\nImplement ctx.rand() using seeded PRNG.\n\n## Acceptance\n- [ ] Returns float in [0, 1)\n- [ ] Deterministic based on seed\n- [ ] Same sequence on replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:33.187312411-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.519590695-06:00","dependencies":[{"issue_id":"nuoc-8gu","depends_on_id":"nuoc-ufl","type":"blocks","created_at":"2026-01-28T07:07:06.425781965-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8h5","title":"[Ctx-23] Implement ctx.invocationId to get current ID","description":"## Micro-task\nImplement ctx.invocationId() to return current invocation's ID.\n\n## Acceptance\n- [ ] Returns current invocation ID\n- [ ] Available throughout handler\n- [ ] Deterministic","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:05.210129542-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.12123396-06:00"}
{"id":"nuoc-8i2","title":"Implement tiered storage — hot cache plus cold archive","description":"## KIRK: Key Intent\nSeparate hot (recent, active) and cold (archived, completed) storage to bound memory/disk usage and enable infinite history retention. Modeled after Restate's tiered storage.\n\n## EARS\n- WHEN a job completes and ages past retention_hot_days, THE SYSTEM SHALL archive it to cold storage (file, S3, etc.).\n- WHERE a query requests archived data, THE SYSTEM SHALL fetch from cold storage transparently.\n- IF cold storage is S3, THE SYSTEM SHALL use object storage APIs with appropriate auth.\n- WHEN archiving, THE SYSTEM SHALL remove data from hot (SQLite) to bound its size.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Tiered storage\n\n  Scenario: Completed job archived\n    Given job J completed 14 days ago\n    And retention_hot_days=7\n    When archiver runs\n    Then J's journal is written to cold storage\n    And J is removed from SQLite (metadata remains)\n\n  Scenario: Query fetches from cold\n    Given job J is archived\n    When event-log J is requested\n    Then events are fetched from cold storage\n    And returned to user transparently\n\n  Scenario: SQLite bounded\n    Given 10000 completed jobs over 30 days\n    And retention_hot_days=7\n    Then SQLite contains only ~2300 jobs' full data\n\\`\\`\\`\n\n## ATDD\n1. Archiver runs daily (configurable)\n2. Cold storage backends: file, S3, GCS\n3. Metadata (job status, times) retained in hot\n4. Lazy fetch from cold on demand\n\n## DBC\n- **Precondition**: Cold storage configured and accessible\n- **Postcondition**: Archived data retrievable\n- **Invariant**: No data loss during archival","status":"open","priority":3,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:43.954209653-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.168699093-06:00","dependencies":[{"issue_id":"nuoc-8i2","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.395998064-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8ik","title":"[Lifecycle-13] Implement paused → running transition (manual resume)","description":"## Micro-task\nOperator resumes paused invocation.\n\n## Acceptance\n- [ ] CLI/API triggers resume\n- [ ] Status updated to running\n- [ ] retry_count optionally reset","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.665116538-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.404457177-06:00","dependencies":[{"issue_id":"nuoc-8ik","depends_on_id":"nuoc-fpb","type":"blocks","created_at":"2026-01-28T07:07:09.510214662-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8nn","title":"Implement OR groups — wait for first of multiple conditions","description":"## KIRK: Key Intent\nEnable workflows to wait for ANY of multiple conditions to complete first (race semantics). Useful for timeouts, alternative paths, and competitive execution. Modeled after Hatchet's OR groups.\n\n## EARS\n- WHEN a task waits on an OR group of conditions [A, B, C], THE SYSTEM SHALL resume when ANY ONE completes first.\n- WHERE the first condition completes, THE SYSTEM SHALL cancel or ignore the remaining conditions.\n- IF multiple conditions complete simultaneously, THE SYSTEM SHALL pick one deterministically (first by ID).\n- WHEN using OR with a timeout, THE SYSTEM SHALL treat the timeout as one of the conditions.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: OR groups\n\n  Scenario: First condition wins\n    Given OR group [awakeable A, timer 60s, child workflow C]\n    When timer completes first at 60s\n    Then workflow resumes with timer result\n    And A and C are cancelled/ignored\n\n  Scenario: Awakeable wins race\n    Given OR group [awakeable A, timer 300s]\n    When A is resolved at 10s\n    Then workflow resumes with A's payload\n    And timer is cancelled\n\n  Scenario: Deterministic tiebreaker\n    Given OR group [A, B] both complete at same instant\n    When resuming\n    Then A is chosen (lower ID)\n\\`\\`\\`\n\n## ATDD\n1. ctx.wait_any([condition1, condition2, ...]) API\n2. Returns (winner_index, result)\n3. Losing conditions cleaned up\n4. Works with awakeables, timers, child workflows\n\n## DBC\n- **Precondition**: OR group has at least 2 conditions\n- **Postcondition**: Exactly one condition's result is returned\n- **Invariant**: No double-resume from OR group","notes":"## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS or_groups (\n  id TEXT PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'WAITING',\n  winner_index INTEGER,\n  winner_result TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  resolved_at TEXT\n);\n\nCREATE TABLE IF NOT EXISTS or_group_conditions (\n  or_group_id TEXT NOT NULL,\n  condition_index INTEGER NOT NULL,\n  condition_type TEXT NOT NULL,\n  condition_id TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'PENDING',\n  result TEXT,\n  PRIMARY KEY (or_group_id, condition_index),\n  FOREIGN KEY (or_group_id) REFERENCES or_groups(id)\n);\n```","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.71607591-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.992573005-06:00","dependencies":[{"issue_id":"nuoc-8nn","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.414819614-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-8nn","depends_on_id":"nuoc-7mg","type":"blocks","created_at":"2026-01-28T06:34:09.529979632-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-8nn","depends_on_id":"nuoc-20c","type":"blocks","created_at":"2026-01-28T06:34:09.549737423-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8q1","title":"[HTTP-10] Implement /attach endpoint","description":"## Micro-task\nPOST /attach waits for existing invocation.\n\n## Acceptance\n- [ ] Finds invocation by ID\n- [ ] Blocks until complete\n- [ ] Returns result","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:21.917608486-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.31982002-06:00","dependencies":[{"issue_id":"nuoc-8q1","depends_on_id":"nuoc-ph8","type":"blocks","created_at":"2026-01-28T07:07:00.990451249-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8r4","title":"[Replay-12] Add replay verification to ctx.awakeable","description":"## Micro-task\nctx.awakeable returns same ID during replay.\n\n## Acceptance\n- [ ] Replayed ctx.awakeable returns cached ID\n- [ ] ID deterministic based on entry_index","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:04.062561161-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.191903002-06:00","dependencies":[{"issue_id":"nuoc-8r4","depends_on_id":"nuoc-c0k","type":"blocks","created_at":"2026-01-28T07:06:54.131550403-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8tv","title":"Implement SQL introspection tables — sys_invocation, sys_journal, etc.","description":"## KIRK: Key Intent\nImplement Restate's SQL introspection interface. Operators can query system state using SQL. Tables include sys_invocation (47 columns), sys_journal, sys_state, etc.\n\n## Introspection Tables\n\n### sys_invocation (invocation state)\nKey columns:\n- id, target, target_service_name, target_service_key, target_handler_name\n- status (pending/scheduled/ready/running/suspended/backing-off/paused/completed)\n- completion_result, completion_failure\n- created_at, modified_at, inboxed_at, scheduled_at, running_at, completed_at\n- retry_count, last_failure, last_failure_error_code\n- journal_size, pinned_deployment_id\n- idempotency_key, invoked_by_id, invoked_by_target\n\n### sys_journal (journal entries)\n- invocation_id, entry_index, entry_type, completed, input, output\n\n### sys_state (virtual object state)\n- service_name, object_key, key, value\n\n### sys_promise (workflow promises)\n- workflow_name, workflow_id, key, status, value\n\n### sys_inbox (pending invocations)\n- invocation_id, service_name, handler_name, created_at\n\n## EARS\n- WHEN a SQL query is issued against sys_*, THE SYSTEM SHALL return current state from underlying tables.\n- WHEN invocation state changes, THE SYSTEM SHALL update sys_invocation immediately.\n- WHERE journal entries are added, THE SYSTEM SHALL reflect them in sys_journal.\n- IF filtering by status, THE SYSTEM SHALL support all 8 invocation states.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: SQL introspection\n\n  Scenario: Query running invocations\n    Given 5 running and 3 completed invocations\n    When \"SELECT * FROM sys_invocation WHERE status = 'running'\"\n    Then 5 rows returned\n\n  Scenario: Query journal for invocation\n    Given invocation \"inv_123\" with 10 journal entries\n    When \"SELECT * FROM sys_journal WHERE invocation_id = 'inv_123'\"\n    Then 10 rows returned in entry_index order\n\n  Scenario: Query virtual object state\n    Given Cart/user-123 has state {items: [...]}\n    When \"SELECT * FROM sys_state WHERE object_key = 'user-123'\"\n    Then state rows returned\n\n  Scenario: Complex query\n    When \"SELECT target_service_name, COUNT(*) FROM sys_invocation GROUP BY target_service_name\"\n    Then aggregated counts returned\n\\`\\`\\`\n\n## Implementation\n\\`\\`\\`sql\n-- Views over existing tables for Restate compatibility\nCREATE VIEW sys_invocation AS\nSELECT \n  id,\n  name as target,\n  -- ... map all 47 columns\nFROM jobs;\n\nCREATE VIEW sys_journal AS\nSELECT\n  job_id as invocation_id,\n  entry_index,\n  entry_type,\n  completed,\n  input,\n  output\nFROM journal_entries;\n\\`\\`\\`\n\n## ATDD\n1. All sys_* tables/views queryable\n2. Column names match Restate exactly\n3. Status values match 8-state lifecycle\n4. Real-time updates reflected\n\n## DBC\n- **Precondition**: Database initialized\n- **Postcondition**: Query results match current state\n- **Invariant**: Views always reflect underlying tables","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:52.186833026-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.856108671-06:00"}
{"id":"nuoc-8v1","title":"Implement cross-service RPC with automatic retries","description":"## KIRK: Key Intent\nEnable workflows to call external services (HTTP, gRPC) with durable RPC semantics — automatic retries, timeout handling, and journaling. Modeled after Restate's cross-service RPC.\n\n## EARS\n- WHEN a task calls ctx.rpc(url, request), THE SYSTEM SHALL journal the call intent before executing.\n- IF the RPC fails transiently, THE SYSTEM SHALL retry with exponential backoff per retry policy.\n- WHEN the RPC succeeds, THE SYSTEM SHALL journal the response and return it.\n- IF the RPC is replayed, THE SYSTEM SHALL return the journaled response without re-calling.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Durable RPC\n\n  Scenario: RPC journaled and replayed\n    Given task calls ctx.rpc(\"https://api.example.com/charge\", {amount: 100})\n    And response is {tx_id: \"abc\"}\n    When workflow replays\n    Then response {tx_id: \"abc\"} returned from journal, no HTTP call made\n\n  Scenario: RPC retry on failure\n    Given RPC fails with 503 on first attempt\n    When retry policy allows 3 attempts\n    Then 2nd attempt succeeds\n    And success response journaled\n\n  Scenario: RPC timeout\n    Given RPC timeout is 30s\n    When server takes 40s to respond\n    Then RPC fails with timeout error\n    And retry triggered\n\\`\\`\\`\n\n## ATDD\n1. ctx.rpc(url, method, body, headers, timeout) API\n2. Retry policy: max_attempts, backoff_base, backoff_max\n3. Idempotency key header sent for safe retries\n4. Response body and status journaled\n\n## DBC\n- **Precondition**: URL is valid, request serializable\n- **Postcondition**: Response journaled on success, retried on transient failure\n- **Invariant**: At-most-once delivery when idempotency key used","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:43.933027046-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.027645151-06:00","dependencies":[{"issue_id":"nuoc-8v1","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.376893357-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-8wi","title":"Implement complete journal entry types — exact Restate parity","description":"## KIRK: Key Intent\nImplement ALL of Restate's journal entry types with exact semantics. Each operation the handler performs becomes a journal entry that can be replayed.\n\n## Journal Entry Types (complete list)\n\n### Input/Output\n- **InputCommandMessage (0x0400)**: Invocation input with headers and value\n- **OutputCommandMessage (0x0401)**: Return value or failure\n\n### State Operations\n- **GetStateCommandMessage (0x0800)**: Retrieve state value (lazy/eager)\n- **SetStateCommandMessage (0x0801)**: Set state key-value\n- **ClearStateCommandMessage (0x0802)**: Delete state key\n- **ClearAllStateCommandMessage (0x0803)**: Delete all state\n- **GetStateKeysCommandMessage (0x0804)**: List state keys\n\n### Promise Operations\n- **GetPromiseCommandMessage (0x0808)**: Await promise (blocking)\n- **PeekPromiseCommandMessage (0x0809)**: Check promise (non-blocking)\n- **CompletePromiseCommandMessage (0x080A)**: Resolve promise\n\n### Durable Operations\n- **SleepCommandMessage (0x0C00)**: Timer with wake_up_time\n- **CallCommandMessage (0x0C01)**: Sync invocation (completable, fallible)\n- **OneWayCallCommandMessage (0x0C02)**: Fire-and-forget with optional delay\n- **AwakeableCommandMessage (0x0C03)**: Create awakeable\n- **CompleteAwakeableCommandMessage (0x0C04)**: Resolve awakeable\n- **RunCommandMessage (0x0C05)**: Execute side effect\n\n### Invocation Management\n- **CancelInvocationCommandMessage (0x0C06)**: Cancel target\n- **GetCallInvocationIdCommandMessage (0x0C07)**: Get call's invocation ID\n- **AttachInvocationCommandMessage (0x0C08)**: Attach to invocation\n- **GetInvocationOutputCommandMessage (0x0C09)**: Get invocation result\n- **SendSignalCommandMessage**: Send signal to invocation\n\n## EARS\n- WHEN a handler performs any journalable operation, THE SYSTEM SHALL create the corresponding entry type with all required fields.\n- WHERE an entry is completable, THE SYSTEM SHALL track completion status and deliver CompletionMessage when done.\n- IF an entry is fallible, THE SYSTEM SHALL handle both success values and Failure objects.\n- WHEN replaying, THE SYSTEM SHALL return stored results for completed entries without re-execution.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Journal entry types\n\n  Scenario: State operations journaled\n    Given handler calls ctx.set(\"key\", \"value\")\n    Then SetStateCommandMessage created with key=\"key\", value=\"value\"\n    When handler calls ctx.get(\"key\")\n    Then GetStateCommandMessage created\n    And completion returns \"value\"\n\n  Scenario: Call vs OneWayCall\n    Given handler calls ctx.call(service, handler, input)\n    Then CallCommandMessage created (completable=true)\n    And handler blocks until completion\n    Given handler calls ctx.send(service, handler, input)\n    Then OneWayCallCommandMessage created\n    And handler continues immediately\n\n  Scenario: Run captures side effect\n    Given handler calls ctx.run(() =\u003e fetch(url))\n    Then RunCommandMessage created\n    When fetch returns data\n    Then entry completed with data\n    On replay: data returned from journal, no fetch\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS journal_entries (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  attempt INTEGER NOT NULL DEFAULT 1,\n  entry_index INTEGER NOT NULL,\n  entry_type INTEGER NOT NULL,\n  entry_name TEXT,\n  flags INTEGER DEFAULT 0,\n  input BLOB,\n  output BLOB,\n  failure_code INTEGER,\n  failure_message TEXT,\n  completed INTEGER DEFAULT 0,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  completed_at TEXT,\n  UNIQUE (job_id, task_name, attempt, entry_index)\n);\n\\`\\`\\`\n\n## ATDD\n1. Every entry type from Restate's protocol is implemented\n2. Completable entries track completion state\n3. Fallible entries handle Failure objects\n4. Entry indexes are sequential per invocation attempt\n\n## DBC\n- **Precondition**: Entry type is valid (known hex code)\n- **Postcondition**: Entry persisted before operation acknowledged\n- **Invariant**: Entry index = previous entry index + 1","status":"in_progress","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:52.187150761-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:56:48.426015844-06:00"}
{"id":"nuoc-91p","title":"Implement child workflows with parent-child lifecycle management","description":"## KIRK: Key Intent\nEnable workflows to spawn child workflows with managed lifecycle relationships. Parent can wait for children, cancel them, or let them run independently. Enables partitioning large workloads and composing workflows. Modeled after Temporal's child workflows.\n\n## EARS\n- WHEN a workflow spawns a child, THE SYSTEM SHALL create a new job with a parent-child relationship recorded.\n- IF the parent is cancelled with policy TERMINATE, THE SYSTEM SHALL cancel all children recursively.\n- IF the parent is cancelled with policy ABANDON, THE SYSTEM SHALL leave children running.\n- WHEN a parent waits for a child, THE SYSTEM SHALL suspend until the child completes and return its result.\n- WHERE parent fails, THE SYSTEM MAY trigger child compensation based on saga configuration.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Child workflows\n\n  Scenario: Parent spawns and waits for child\n    Given parent workflow P spawns child C\n    When P awaits C\n    Then P suspends until C completes\n    And P receives C's result\n\n  Scenario: Parent cancellation terminates children\n    Given P has children C1, C2, C3 with policy TERMINATE\n    When P is cancelled\n    Then C1, C2, C3 are all cancelled\n\n  Scenario: Parent cancellation abandons children\n    Given P has child C with policy ABANDON\n    When P is cancelled\n    Then C continues running independently\n\n  Scenario: Child failure propagates to parent\n    Given P awaits child C\n    When C fails\n    Then P receives the failure and can handle it\n\\`\\`\\`\n\n## ATDD\n1. ctx.spawn_child(workflow_name, input, policy) API\n2. Parent-child relationship tracked in jobs table\n3. Cancellation cascades per policy\n4. Child result available via ctx.wait_child(child_id)\n\n## DBC\n- **Precondition**: Parent is in RUNNING state when spawning\n- **Postcondition**: Child job created with parent_id set\n- **Invariant**: TERMINATE policy ensures no orphaned children\n\n## Schema Addition\n\\`\\`\\`sql\nALTER TABLE jobs ADD COLUMN parent_id TEXT REFERENCES jobs(id);\nALTER TABLE jobs ADD COLUMN child_policy TEXT DEFAULT 'TERMINATE';\n\\`\\`\\`","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:46.722761811-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.620895531-06:00","dependencies":[{"issue_id":"nuoc-91p","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.270353036-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-954","title":"Fail on unrecognized condition patterns instead of defaulting to true","description":"## KIRK: Key Intent\neval-condition silently returns true for any unrecognized condition pattern, meaning misconfigured conditions never block. This defeats the purpose of conditional execution.\n\n## EARS\n- WHEN eval-condition encounters a condition string that does not match any supported pattern, THE SYSTEM SHALL return false and log a warning event.\n- IF the condition is empty or null, THEN eval-condition SHALL return true (unconditional execution).\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Condition evaluation safety\n\n  Scenario: Recognized pattern evaluated\n    Given condition \\\"{{ tasks.triage.route contains 4 }}\\\"\n    When eval-condition is called\n    Then it returns the correct boolean based on triage output\n\n  Scenario: Unrecognized pattern fails safe\n    Given condition \\\"{{ some.unknown.pattern }}\\\"\n    When eval-condition is called\n    Then it returns false\n    And an event is emitted with type \\\"condition.UnrecognizedPattern\\\"\n\n  Scenario: Empty condition passes\n    Given condition \\\"\\\"\n    When eval-condition is called\n    Then it returns true\n\\`\\`\\`\n\n## ATDD\n1. Every condition string in oc-tdd15.nu task definitions is parseable by eval-condition\n2. A typo in a condition pattern causes the task to be skipped, not silently executed\n\n## DBC\n- **Precondition**: condition is a string (may be empty)\n- **Postcondition**: Returns true only if condition is empty OR matches a recognized pattern that evaluates to true\n- **Invariant**: No unrecognized pattern ever returns true\n\n## Files\n- oc-engine.nu:423-443 (eval-condition)","status":"open","priority":1,"issue_type":"bug","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:23:53.781682021-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.772704379-06:00"}
{"id":"nuoc-99c","title":"[HTTP-06] Implement idempotency cache lookup","description":"## Micro-task\nCheck cache before creating invocation.\n\n## Acceptance\n- [ ] Returns cached response if exists\n- [ ] Returns null if not cached\n- [ ] Expired entries ignored","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:17.611069572-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.417789796-06:00","dependencies":[{"issue_id":"nuoc-99c","depends_on_id":"nuoc-752","type":"blocks","created_at":"2026-01-28T07:07:00.908944053-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-9kl","title":"[Entity-02] Implement entity registration command","description":"## Micro-task\nCommand to register an entity with its handlers.\n\n## Deliverable\n\\`\\`\\`nu\nexport def entity-register [name: string, entity_type: string, handlers: list] {\n  sql-exec \\$\"INSERT INTO entity_definitions ...\"\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Entity stored in database\n- [ ] Handlers validated\n- [ ] Duplicate names rejected","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:06.202990372-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.0709875-06:00","dependencies":[{"issue_id":"nuoc-9kl","depends_on_id":"nuoc-bp1","type":"blocks","created_at":"2026-01-28T07:06:56.976880446-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-9r9","title":"[TUI-11] Implement metrics panel","description":"## Micro-task\nDashboard with job/task metrics.\n\n## Metrics\n- Avg duration per phase\n- Retry rate\n- Regression count\n- Gate pass rate\n\n## Acceptance\n- [ ] Metrics computed from DB\n- [ ] Displayed as gauges/charts\n- [ ] 'm' key toggles view","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:32.710484696-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.151356212-06:00","dependencies":[{"issue_id":"nuoc-9r9","depends_on_id":"nuoc-xma","type":"blocks","created_at":"2026-01-28T07:07:06.682796116-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-9w6","title":"[Awk-01] Create awakeables table schema","description":"## Micro-task\nSchema for awakeable tracking.\n\n## Schema\n```sql\nCREATE TABLE awakeables (\n  id TEXT PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  entry_index INTEGER NOT NULL,\n  status TEXT DEFAULT 'PENDING',\n  payload TEXT,\n  timeout_at TEXT,\n  created_at TEXT DEFAULT (datetime('now')),\n  resolved_at TEXT\n);\n```\n\n## Acceptance\n- [ ] Table created\n- [ ] Index on (job_id, task_name)","notes":"TDD15 complete - awaiting Red Queen evolution","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.792749758-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T22:24:42.100338143-06:00","closed_at":"2026-01-28T22:24:42.100338143-06:00","close_reason":"TDD15 + Red Queen complete - battle-hardened schema implementation"}
{"id":"nuoc-9y8","title":"[Entity-13] Implement workflow signal handlers","description":"## Micro-task\nWorkflows have signal handlers that run concurrently with run handler.\n\n## Acceptance\n- [ ] Signal handlers can be invoked anytime\n- [ ] Read-only access to state\n- [ ] Can complete promises","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:19.155532615-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.665966469-06:00","dependencies":[{"issue_id":"nuoc-9y8","depends_on_id":"nuoc-1zd","type":"blocks","created_at":"2026-01-28T07:07:02.343464857-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-a1o","title":"[Ctx-20] Implement ctx.cancel for cooperative cancellation","description":"## Micro-task\nImplement ctx.cancel(invocationId) for cooperative cancellation.\n\n## Acceptance\n- [ ] Sets cancellation flag on target\n- [ ] Target receives exception at await points\n- [ ] Non-blocking","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:01.398062508-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.305606592-06:00"}
{"id":"nuoc-a7ti","title":"[Awk-06] Implement resolve-awakeable command","description":"## Micro-task\nCLI command to resolve awakeable.\n\n## Command\n```nu\nexport def resolve-awakeable [id: string, payload: any] {\n  # Parse ID, update awakeable, wake task\n}\n```\n\n## Acceptance\n- [ ] Awakeable marked resolved\n- [ ] Payload stored\n- [ ] Task woken","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.894336287-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:35:48.014958758-06:00","closed_at":"2026-01-28T23:35:48.014960948-06:00","dependencies":[{"issue_id":"nuoc-a7ti","depends_on_id":"nuoc-pvb2","type":"blocks","created_at":"2026-01-28T07:07:04.427513643-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-aa6","title":"[Replay-05] Add entry_index counter to task execution context","description":"## Micro-task\nTrack current entry_index during task execution. Each journalable operation increments it.\n\n## Deliverable\n- Add \\$env.CURRENT_ENTRY_INDEX or context record\n- next-entry-index command that increments and returns\n- Reset to 0 at task start\n\n## Acceptance\n- [ ] Counter starts at 0 for new task\n- [ ] Increments on each journal operation\n- [ ] Accessible from ctx.* commands","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:05.936648124-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.087935689-06:00","dependencies":[{"issue_id":"nuoc-aa6","depends_on_id":"nuoc-xtp","type":"blocks","created_at":"2026-01-28T07:06:53.989696548-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ahn","title":"[Proto-06] Implement ErrorMessage structure","description":"## Micro-task\nErrorMessage for invocation failures.\n\n## Fields\n- code: HTTP status\n- message: short error\n- description: detailed explanation\n- related_entry_index: optional\n- related_entry_name: optional\n\n## Acceptance\n- [ ] All fields defined\n- [ ] Sent on handler error","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:17.824330825-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.404228218-06:00","dependencies":[{"issue_id":"nuoc-ahn","depends_on_id":"nuoc-43v","type":"blocks","created_at":"2026-01-28T07:06:59.128814518-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ajp","title":"Implement Services, Virtual Objects, and Workflows as distinct entity types","description":"## KIRK: Key Intent\nImplement Restate's three entity types: Services (stateless), Virtual Objects (keyed stateful with single-writer), and Workflows (exactly-once orchestration). Currently we only have \"jobs\" without this distinction.\n\n## Entity Types\n\n### Services\n- **Purpose**: Stateless logic, unlimited parallelism\n- **Context**: Basic Context (no state methods)\n- **Concurrency**: Unlimited parallel execution\n- **State**: None\n- **Use**: API calls, background jobs, parallelization\n\n### Virtual Objects\n- **Purpose**: Stateful entities identified by key\n- **Context**: ObjectContext (get/set/clear state)\n- **Concurrency**: Single writer per key, concurrent readers\n- **State**: Isolated K/V per object key\n- **Use**: User accounts, shopping carts, AI agents\n\n### Workflows\n- **Purpose**: Multi-step exactly-once orchestration\n- **Context**: WorkflowContext (run handler), WorkflowSharedContext (other handlers)\n- **Concurrency**: Single 'run' execution per workflow ID\n- **State**: Managed by runtime (durable promises, not K/V)\n- **Use**: Sagas, human-in-the-loop, event-driven flows\n\n## EARS\n- WHEN a Service is invoked, THE SYSTEM SHALL allow unlimited parallel executions.\n- WHEN a Virtual Object is invoked with key K, THE SYSTEM SHALL serialize write handlers on K.\n- WHEN a Workflow's run handler is invoked, THE SYSTEM SHALL execute exactly once per workflow ID.\n- WHERE a handler type requires state, THE SYSTEM SHALL provide appropriate context methods.\n- IF a Virtual Object write handler is running for key K, THE SYSTEM SHALL queue other write requests for K.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Entity types\n\n  Scenario: Service parallelism\n    Given Service \"EmailSender\"\n    When 100 concurrent invocations arrive\n    Then all 100 execute in parallel\n\n  Scenario: Virtual Object single-writer\n    Given Virtual Object \"Cart\" with key \"user-123\"\n    When write handler H1 is running\n    And write handler H2 arrives for same key\n    Then H2 queues until H1 completes\n\n  Scenario: Virtual Object concurrent readers\n    Given Virtual Object \"Cart\" with key \"user-123\"\n    When write handler is NOT running\n    Then multiple read handlers can execute concurrently\n\n  Scenario: Workflow exactly-once\n    Given Workflow \"OrderProcess\" with ID \"order-456\"\n    When run handler completes\n    And same workflow ID invoked again\n    Then cached result returned, no re-execution\n\n  Scenario: Workflow signal handlers\n    Given Workflow \"OrderProcess\" running\n    When signal handler \"updateAddress\" invoked\n    Then it executes concurrently with run handler\n    And has read-only access to state\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS entity_definitions (\n  name TEXT PRIMARY KEY,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('service', 'virtual_object', 'workflow')),\n  handlers TEXT NOT NULL, -- JSON array of handler definitions\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\nCREATE TABLE IF NOT EXISTS virtual_object_locks (\n  entity_name TEXT NOT NULL,\n  object_key TEXT NOT NULL,\n  holder_invocation_id TEXT,\n  acquired_at TEXT,\n  PRIMARY KEY (entity_name, object_key)\n);\n\nCREATE TABLE IF NOT EXISTS workflow_runs (\n  workflow_name TEXT NOT NULL,\n  workflow_id TEXT NOT NULL,\n  run_invocation_id TEXT,\n  status TEXT NOT NULL DEFAULT 'pending',\n  result TEXT,\n  PRIMARY KEY (workflow_name, workflow_id)\n);\n\\`\\`\\`\n\n## ATDD\n1. Service invocations never queue (unlimited parallel)\n2. Virtual Object write handlers serialize per key\n3. Workflow run handler executes exactly once per ID\n4. Context methods match entity type capabilities\n\n## DBC\n- **Precondition**: Entity type and handler registered\n- **Postcondition**: Concurrency constraints enforced per type\n- **Invariant**: Virtual Object key has at most one write handler active","status":"closed","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:54.015372717-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T07:09:58.89136455-06:00","closed_at":"2026-01-29T07:09:58.89136745-06:00"}
{"id":"nuoc-al8","title":"[Proto-07] Implement EndMessage structure","description":"## Micro-task\nEndMessage for successful completion.\n\n## Fields (minimal)\n- (may be empty, just signals success)\n\n## Acceptance\n- [ ] Sent when handler returns successfully","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:18.684903674-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.388256826-06:00","dependencies":[{"issue_id":"nuoc-al8","depends_on_id":"nuoc-43v","type":"blocks","created_at":"2026-01-28T07:06:59.15020871-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-amk","title":"Fix par-each race condition in regression during parallel task execution","description":"## KIRK: Key Intent\nPrevent parallel tasks from executing against stale state when a sibling triggers regression.\n\n## EARS\n- WHEN a task triggers regression via on_fail_regress WHILE sibling tasks are executing in parallel, THEN the engine SHALL cancel or invalidate all in-flight sibling tasks before resetting the regression target.\n- AFTER regression resets tasks to PENDING, THE SYSTEM SHALL NOT have any RUNNING tasks downstream of the regression target.\n\n## BDD Scenarios\n```gherkin\nFeature: Regression cancels parallel siblings\n\n  Scenario: Sibling cancelled on regression\n    Given tasks A, B, C all depend on task X and run in parallel\n    And task A fails with regression to X\n    When regression is triggered\n    Then tasks B and C are cancelled if still running\n    And task X is reset to PENDING\n    And tasks A, B, C are reset to PENDING\n\n  Scenario: Completed sibling not affected by unrelated regression\n    Given task B completed before task A triggered regression\n    And task B is NOT downstream of the regression target\n    Then task B remains COMPLETED\n```\n\n## ATDD\n1. Simulate parallel execution where one task fails with regression — verify no task remains RUNNING after regression completes\n2. Verify regression_count increments on each regression cycle\n3. After regression, the next execution loop re-evaluates all dependencies correctly\n\n## DBC\n- **Precondition**: regression target task exists in the job\n- **Postcondition**: After task-regress, zero tasks downstream of target are in RUNNING state\n- **Invariant**: No task executes while any of its transitive dependencies are in non-terminal state (PENDING/RUNNING)\n\n## Files\n- oc-engine.nu:185-227 (job-execute main loop, par-each, regression check)\n- oc-engine.nu:400-418 (task-regress, find-downstream)","notes":"## Additional Edge Case Scenarios\n```gherkin\n  Scenario: Deeply nested regression chain\n    Given task chain A -\u003e B -\u003e C -\u003e D -\u003e E\n    And E fails with regression to B\n    When regression executes\n    Then C, D, E are all reset to PENDING\n    And B is reset to PENDING\n    And A remains COMPLETED\n\n  Scenario: Parallel siblings at different depths\n    Given DAG with parallel branches:\n      A -\u003e B -\u003e D\n      A -\u003e C -\u003e E\n    And D and E run in parallel\n    When D fails with regression to A\n    Then E is cancelled mid-execution\n    And B, C, D, E all reset to PENDING\n\n  Scenario: Regression during retry backoff\n    Given task B is in retry backoff (attempt 2, waiting 4s)\n    When sibling task C triggers regression to A\n    Then B's retry is cancelled\n    And B is reset to PENDING with attempt=0\n```","status":"open","priority":1,"issue_type":"bug","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:22:13.010799038-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.805291212-06:00","dependencies":[{"issue_id":"nuoc-amk","depends_on_id":"nuoc-60i","type":"blocks","created_at":"2026-01-28T02:24:58.615674635-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-arf","title":"[Ctx-13] Implement ctx.resolveAwakeable","description":"## Micro-task\nImplement ctx.resolveAwakeable(id, value) to complete awakeable with success.\n\n## Acceptance\n- [ ] Awakeable marked resolved\n- [ ] Waiting task resumed with value\n- [ ] Journaled","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:30.982263769-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.55115025-06:00","dependencies":[{"issue_id":"nuoc-arf","depends_on_id":"nuoc-d56","type":"blocks","created_at":"2026-01-28T07:06:59.578258571-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-as3","title":"[Ctx-02] Implement ctx.set for state mutation","description":"## Micro-task\nImplement ctx.set(key, value) to set state for virtual objects.\n\n## Deliverable\n\\`\\`\\`nu\nexport def \"ctx set\" [key: string, value: any] {\n  let idx = (next-entry-index)\n  sql-exec $\"INSERT OR REPLACE INTO keyed_state (key, field, value) VALUES (...)\"\n  journal-write ... $idx \"set_state\" {key: $key, value: $value} null\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] State persisted to keyed_state table\n- [ ] Operation journaled\n- [ ] Idempotent on replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:01.397440416-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.321516634-06:00","dependencies":[{"issue_id":"nuoc-as3","depends_on_id":"nuoc-ufl","type":"blocks","created_at":"2026-01-28T07:06:56.107983468-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-b9r","title":"[TUI-04] Implement job list query from SQLite","description":"## Micro-task\nQuery jobs table and deserialize into Job structs.\n\n## Acceptance\n- [ ] All jobs loaded\n- [ ] Status, name, timestamps parsed\n- [ ] Sorted by position, created_at","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:22.774039891-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.285613451-06:00","dependencies":[{"issue_id":"nuoc-b9r","depends_on_id":"nuoc-xma","type":"blocks","created_at":"2026-01-28T07:07:06.529588233-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bdj","title":"[Entity-06] Implement lock release for virtual objects","description":"## Micro-task\nRelease lock on virtual object key.\n\n## Acceptance\n- [ ] Lock removed from table\n- [ ] Only holder can release\n- [ ] Queued invocations notified","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:10.962638278-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.828429764-06:00","dependencies":[{"issue_id":"nuoc-bdj","depends_on_id":"nuoc-eml","type":"blocks","created_at":"2026-01-28T07:06:57.037284396-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bfxa","title":"[Awk-10] Implement duplicate resolution rejection","description":"## Micro-task\nReject resolution if already resolved.\n\n## Acceptance\n- [ ] Error if status != PENDING\n- [ ] Original payload preserved\n- [ ] Clear error message","notes":"TDD15 complete - duplicate resolution rejection implemented and tested","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.972281877-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:40:44.116083495-06:00","closed_at":"2026-01-28T23:40:44.116086695-06:00","dependencies":[{"issue_id":"nuoc-bfxa","depends_on_id":"nuoc-a7ti","type":"blocks","created_at":"2026-01-28T07:07:04.533647282-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bjv","title":"[Lifecycle-02] Add scheduled_start_at column for delayed invocations","description":"## Micro-task\nAdd column to track when scheduled invocations should start.\n\n## Acceptance\n- [ ] Column added to jobs table\n- [ ] Null means not scheduled\n- [ ] Timestamp stored as TEXT","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.443490974-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.581900896-06:00","dependencies":[{"issue_id":"nuoc-bjv","depends_on_id":"nuoc-j14","type":"blocks","created_at":"2026-01-28T07:07:02.384475282-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bp1","title":"[Entity-01] Create entity_definitions table schema","description":"## Micro-task\nCreate schema to store entity (service/virtual_object/workflow) definitions.\n\n## Deliverable\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS entity_definitions (\n  name TEXT PRIMARY KEY,\n  entity_type TEXT NOT NULL CHECK (entity_type IN ('service', 'virtual_object', 'workflow')),\n  handlers TEXT NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\\`\\`\\`\n\n## Acceptance\n- [ ] Table created in db-init\n- [ ] entity_type constrained to valid values\n- [ ] handlers stored as JSON","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:04.366901732-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.157667914-06:00"}
{"id":"nuoc-bsx","title":"[Replay-07] Modify run-task to load journal on start","description":"## Micro-task\nWhen task starts, load existing journal entries and set known_entries count.\n\n## Deliverable\n\\`\\`\\`nu\n# In run-task, before execution:\nlet journal = (journal-read \\$job_id \\$task_name \\$attempt)\nlet known_entries = (\\$journal | length)\n\\$env.KNOWN_ENTRIES = \\$known_entries\n\\$env.REPLAY_MODE = \\$known_entries \u003e 0\n\\$env.CURRENT_ENTRY_INDEX = 0\n\\`\\`\\`\n\n## Acceptance\n- [ ] Journal loaded at task start\n- [ ] known_entries set correctly\n- [ ] REPLAY_MODE initialized","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:08.727641777-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:03:54.218623104-06:00","closed_at":"2026-01-29T05:03:54.218625274-06:00","dependencies":[{"issue_id":"nuoc-bsx","depends_on_id":"nuoc-xgo","type":"blocks","created_at":"2026-01-28T07:06:54.029337089-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bx9","title":"Implement epoch-based fencing for exactly-once during failover","description":"## KIRK: Key Intent\nImplement Restate's epoch-based fencing to prevent split-brain during failover. Each execution attempt gets a monotonically increasing epoch. Messages from superseded epochs are rejected.\n\n## Mechanism\n1. Each invocation attempt gets unique epoch (monotonically increasing)\n2. All journal events tagged with epoch\n3. Processor tracks current epoch per invocation\n4. Events from old epochs rejected (late messages from crashed workers)\n5. New leader appends epoch-bump record on takeover\n\n## EARS\n- WHEN a new execution attempt starts, THE SYSTEM SHALL assign epoch = previous_epoch + 1.\n- WHEN a journal event is received, THE SYSTEM SHALL verify event.epoch \u003e= current_epoch.\n- IF event.epoch \u003c current_epoch, THE SYSTEM SHALL reject the event as superseded.\n- WHEN a worker crashes and another takes over, THE SYSTEM SHALL bump epoch before processing.\n- WHERE an epoch bump occurs, THE SYSTEM SHALL record it in the journal.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Epoch-based fencing\n\n  Scenario: Normal execution\n    Given invocation starts with epoch=1\n    When journal event arrives with epoch=1\n    Then event is accepted\n\n  Scenario: Superseded epoch rejected\n    Given current epoch=3 for invocation\n    When journal event arrives with epoch=2\n    Then event is rejected with \"superseded epoch\"\n    And no state change occurs\n\n  Scenario: Failover bumps epoch\n    Given worker W1 processing invocation at epoch=2\n    When W1 crashes and W2 takes over\n    Then W2 assigns epoch=3\n    And epoch-bump record written to journal\n    And any late messages from W1 (epoch=2) rejected\n\n  Scenario: Split-brain prevention\n    Given network partition isolates W1\n    And W2 takes over with epoch=3\n    When partition heals and W1 tries to continue with epoch=2\n    Then all W1's events rejected\n    And only W2's events accepted\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nALTER TABLE jobs ADD COLUMN current_epoch INTEGER DEFAULT 1;\n\n-- Epoch bump events in journal\n-- entry_type = 'EPOCH_BUMP' with new epoch value\n\\`\\`\\`\n\n## ATDD\n1. Epochs are strictly monotonic per invocation\n2. Events with old epochs are rejected at persistence layer\n3. Failover correctly bumps epoch\n4. No duplicate effects from superseded attempts\n\n## DBC\n- **Precondition**: Epoch is positive integer\n- **Postcondition**: current_epoch \u003e= event.epoch for all accepted events\n- **Invariant**: current_epoch never decreases","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:59:00.228970974-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.535513005-06:00"}
{"id":"nuoc-bxis","title":"[Worker-01] Create task_queues table schema","description":"## Micro-task\nSchema for task queue entries.\n\n## Schema\n```sql\nCREATE TABLE task_queues (\n  id INTEGER PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  queue_name TEXT NOT NULL,\n  status TEXT DEFAULT 'QUEUED',\n  claimed_by TEXT,\n  claimed_at TEXT,\n  heartbeat_at TEXT,\n  enqueued_at TEXT DEFAULT (datetime('now')),\n  UNIQUE (job_id, task_name)\n);\n```\n\n## Acceptance\n- [ ] Table created\n- [ ] Indexes for queue_name, status","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.873569323-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.016998382-06:00"}
{"id":"nuoc-byf","title":"[TUI-15] Implement retry job action","description":"## Micro-task\n'r' key retries selected job.\n\n## Acceptance\n- [ ] job-retry called\n- [ ] UI updates\n- [ ] Works for FAILED/PAUSED jobs","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:37.866014042-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.08060542-06:00","dependencies":[{"issue_id":"nuoc-byf","depends_on_id":"nuoc-n5m","type":"blocks","created_at":"2026-01-28T07:07:06.769058786-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-bze","title":"[TUI-18] Handle terminal resize","description":"## Micro-task\nRecompute layout on terminal resize.\n\n## Acceptance\n- [ ] SIGWINCH handled\n- [ ] Layout recomputed\n- [ ] No crashes on small terminals","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:41.444175717-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.033087554-06:00","dependencies":[{"issue_id":"nuoc-bze","depends_on_id":"nuoc-37v","type":"blocks","created_at":"2026-01-28T07:07:06.82928167-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-c0k","title":"[Replay-09] Implement non-determinism detection comparing commands","description":"## Micro-task\nDuring replay, verify generated command matches journaled command. Raise error on mismatch.\n\n## Deliverable\n```nu\ndef verify-replay-entry [entry_index: int, op_type: string, input: any] {\n  let cached = (sql $\"SELECT op_type, input_hash FROM journal WHERE ...\")\n  if ($cached.op_type != $op_type) {\n    error make {msg: $\"Non-determinism: expected ($cached.op_type) at ($entry_index), got ($op_type)\"}\n  }\n  let current_hash = ($input | to json -r | hash sha256)\n  if ($cached.input_hash != $current_hash) {\n    error make {msg: $\"Non-determinism: input mismatch at entry ($entry_index)\"}\n  }\n}\n```\n\n## Acceptance\n- [ ] Detects op_type mismatch\n- [ ] Detects input_hash mismatch\n- [ ] Clear error message with entry_index","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:01:59.917543076-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.63071601-06:00","dependencies":[{"issue_id":"nuoc-c0k","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:54.068681183-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-c4e","title":"[Proto-10] Implement bidirectional stream abstraction","description":"## Micro-task\nAbstract bidirectional message stream (over HTTP, pipes, etc.)\n\n## Acceptance\n- [ ] Send message to handler\n- [ ] Receive message from handler\n- [ ] Works over multiple transports","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:22.447903969-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.340149789-06:00","dependencies":[{"issue_id":"nuoc-c4e","depends_on_id":"nuoc-pjh","type":"blocks","created_at":"2026-01-28T07:06:59.210038948-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-cc0","title":"[Proto-04] Implement CompletionMessage structure","description":"## Micro-task\nCompletionMessage for journal entry completions.\n\n## Fields\n- entry_index: which entry completed\n- result: success value or failure\n\n## Acceptance\n- [ ] Struct defined\n- [ ] Handles success and failure\n- [ ] Serialization works","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:14.922056074-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.435288024-06:00","dependencies":[{"issue_id":"nuoc-cc0","depends_on_id":"nuoc-43v","type":"blocks","created_at":"2026-01-28T07:06:59.087030443-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-cetw","title":"[Worker-02] Create workers table schema","description":"## Micro-task\nSchema for worker registration.\n\n## Schema\n```sql\nCREATE TABLE workers (\n  id TEXT PRIMARY KEY,\n  queues TEXT NOT NULL,\n  max_slots INTEGER DEFAULT 5,\n  active_slots INTEGER DEFAULT 0,\n  last_heartbeat TEXT,\n  registered_at TEXT DEFAULT (datetime('now'))\n);\n```\n\n## Acceptance\n- [ ] Table created\n- [ ] Worker ID unique","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.892885434-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.000846631-06:00","dependencies":[{"issue_id":"nuoc-cetw","depends_on_id":"nuoc-bxis","type":"blocks","created_at":"2026-01-28T07:07:02.522734614-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-csp","title":"[Proto-08] Implement message serialization","description":"## Micro-task\nSerialize messages to binary format with header.\n\n## Acceptance\n- [ ] Header prepended\n- [ ] Payload serialized (JSON for nushell compatibility)\n- [ ] Length calculated correctly","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:19.966443345-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.371725935-06:00","dependencies":[{"issue_id":"nuoc-csp","depends_on_id":"nuoc-jtr","type":"blocks","created_at":"2026-01-28T07:06:59.170452266-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-d56","title":"[Ctx-12] Implement ctx.awakeable to create awaitable","description":"## Micro-task\nImplement ctx.awakeable() returning {id, promise}.\n\n## Acceptance\n- [ ] Returns unique awakeable ID\n- [ ] Promise blocks until resolved\n- [ ] ID format matches Restate spec","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:24.539565622-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.566998703-06:00","dependencies":[{"issue_id":"nuoc-d56","depends_on_id":"nuoc-9w6","type":"blocks","created_at":"2026-01-28T07:06:59.558048005-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ddg","title":"Implement sticky sessions — route tasks to same worker for cache locality","description":"## KIRK: Key Intent\nRoute tasks with the same affinity key to the same worker for cache locality. Useful when tasks benefit from warm caches, loaded models, or persistent connections. Modeled after Hatchet's sticky sessions.\n\n## EARS\n- WHEN a task has a sticky_key, THE SYSTEM SHALL prefer routing it to the worker that last processed that key.\n- IF the preferred worker is unavailable, THE SYSTEM SHALL fall back to any available worker and update the affinity.\n- WHERE sticky_ttl is configured, THE SYSTEM SHALL expire the affinity after that duration of inactivity.\n- WHEN a worker crashes, THE SYSTEM SHALL reassign its sticky keys to other workers.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Sticky sessions\n\n  Scenario: Same key routes to same worker\n    Given task T1 with sticky_key=\"model-gpt4\" executed on worker W1\n    When task T2 with sticky_key=\"model-gpt4\" is queued\n    Then T2 is routed to W1\n\n  Scenario: Fallback on unavailable worker\n    Given sticky_key=\"model-gpt4\" affinity to W1\n    And W1 is offline\n    When task with that key is queued\n    Then it routes to available worker W2\n    And affinity updates to W2\n\n  Scenario: Affinity expires\n    Given sticky_key=\"model-gpt4\" last used 1h ago\n    And sticky_ttl=30m\n    When task with that key is queued\n    Then any worker can claim it\n\\`\\`\\`\n\n## ATDD\n1. sticky_key in task definition\n2. Affinity table tracks key -\u003e worker mapping\n3. TTL-based expiration\n4. Metrics: cache hit rate for sticky routing\n\n## DBC\n- **Precondition**: Worker exists for fallback\n- **Postcondition**: Task routed to worker with affinity or best available\n- **Invariant**: Affinity is advisory, not mandatory (availability trumps affinity)\n\n## Schema Addition\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS sticky_affinity (\n  sticky_key TEXT PRIMARY KEY,\n  worker_id TEXT NOT NULL,\n  last_used TEXT NOT NULL DEFAULT (datetime('now')),\n  ttl_sec INTEGER DEFAULT 1800\n);\n\\`\\`\\`","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.735122247-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.974949827-06:00","dependencies":[{"issue_id":"nuoc-ddg","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T06:34:09.473418383-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-dk2","title":"[Ctx-09] Implement ctx.run for side effects","description":"## Micro-task\nImplement ctx.run(closure) for executing and journaling side effects.\n\n## Acceptance\n- [ ] Closure executed and result journaled\n- [ ] Replays return cached result\n- [ ] No ctx.* calls allowed inside closure","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:21.171504896-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.614963779-06:00"}
{"id":"nuoc-dla","title":"Populate duration_ms and remove dead webhooks table or implement it","description":"## KIRK: Key Intent\nduration_ms column exists but is never written. webhooks table is created but never used. Dead schema is technical debt that misleads readers about capabilities.\n\n## EARS\n- WHEN a task transitions to COMPLETED or FAILED, THE SYSTEM SHALL compute duration_ms from started_at to completed_at and store it.\n- IF the webhooks table has no implementation plan, THEN it SHALL be removed from db-init.\n- WHERE duration_ms is populated, THE SYSTEM SHALL expose it in job-status output.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Schema hygiene\n\n  Scenario: Duration tracked on completion\n    Given a task starts at T0 and completes at T0+500ms\n    When the task status is queried\n    Then duration_ms is approximately 500\n\n  Scenario: Webhooks table removed\n    Given db-init runs\n    When the schema is inspected\n    Then no webhooks table exists (unless webhook feature is implemented)\n\\`\\`\\`\n\n## ATDD\n1. After any task completes, duration_ms is non-null\n2. job-status includes duration_ms per task\n3. No dead tables in schema\n\n## DBC\n- **Precondition**: started_at is set before duration calculation\n- **Postcondition**: duration_ms = completed_at - started_at in milliseconds\n- **Invariant**: Every column in schema is read by at least one query\n\n## Files\n- oc-engine.nu:10-88 (schema)\n- oc-engine.nu:305-310 (task completion — add duration calc)\n- oc-engine.nu:530-539 (job-status)","status":"open","priority":3,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:24:43.828617414-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.190199812-06:00"}
{"id":"nuoc-doz1","title":"[Worker-08] Implement dead worker detection","description":"## Micro-task\nDetect workers with stale heartbeats.\n\n## Acceptance\n- [ ] Workers with heartbeat \u003e 30s ago = dead\n- [ ] Dead workers' tasks re-queued\n- [ ] Worker record cleaned up","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.011687921-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.901231987-06:00","dependencies":[{"issue_id":"nuoc-doz1","depends_on_id":"nuoc-tvhk","type":"blocks","created_at":"2026-01-28T07:07:02.667021053-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ebe","title":"Implement deterministic RNG — ctx.rand with random_seed","description":"## KIRK: Key Intent\nImplement Restate's deterministic random number generation. The StartMessage includes a random_seed, and ctx.rand() uses it to produce reproducible sequences across replays.\n\n## Mechanism\n1. StartMessage includes random_seed (u64)\n2. ctx.rand() uses seeded PRNG (e.g., xorshift, PCG)\n3. Same seed + same call sequence = same outputs\n4. Enables deterministic replay with \"random\" values\n\n## EARS\n- WHEN StartMessage is received, THE SYSTEM SHALL initialize PRNG with random_seed.\n- WHEN ctx.rand() is called, THE SYSTEM SHALL return next value from seeded PRNG.\n- WHEN replaying, THE SYSTEM SHALL use same seed to produce identical sequence.\n- WHERE ctx.rand.uuidv4() is called, THE SYSTEM SHALL generate deterministic UUID from PRNG.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Deterministic RNG\n\n  Scenario: Reproducible sequence\n    Given StartMessage with random_seed=42\n    When ctx.rand() called 3 times\n    Then values are [0.374..., 0.891..., 0.123...]\n    On replay with same seed\n    Then same values produced\n\n  Scenario: Deterministic UUID\n    Given random_seed=42\n    When ctx.rand.uuidv4() called\n    Then UUID is \"550e8400-e29b-...\"\n    On replay: same UUID produced\n\n  Scenario: Different seeds, different values\n    Given random_seed=42 produces [a, b, c]\n    And random_seed=99 produces [x, y, z]\n    Then [a,b,c] != [x,y,z]\n\\`\\`\\`\n\n## Implementation\n\\`\\`\\`nu\n# Use xorshift64* or similar fast PRNG\ndef rand-init [seed: int] {\n  $env.PRNG_STATE = $seed\n}\n\ndef \"ctx rand\" [] {\n  # xorshift64*\n  mut state = $env.PRNG_STATE\n  $state = ($state | bits xor ($state | bits shr 12))\n  $state = ($state | bits xor ($state | bits shl 25))\n  $state = ($state | bits xor ($state | bits shr 27))\n  $env.PRNG_STATE = $state\n  ($state * 0x2545F4914F6CDD1D) / 18446744073709551615.0\n}\n\ndef \"ctx rand uuidv4\" [] {\n  # Generate 16 random bytes, format as UUID\n  let bytes = (0..15 | each { ctx rand | * 256 | math floor })\n  # Set version (4) and variant bits\n  ...format as UUID string...\n}\n\\`\\`\\`\n\n## ATDD\n1. Same seed produces identical sequence\n2. ctx.rand() returns float in [0, 1)\n3. ctx.rand.uuidv4() produces valid v4 UUID\n4. Replay produces identical \"random\" values\n\n## DBC\n- **Precondition**: PRNG initialized with seed from StartMessage\n- **Postcondition**: Deterministic output for given seed and call count\n- **Invariant**: No external entropy sources used","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:55.189604126-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.822948649-06:00"}
{"id":"nuoc-ebn","title":"[Replay-10] Add replay verification to ctx.call","description":"## Micro-task\nctx.call verifies target and input match during replay.\n\n## Acceptance\n- [ ] Replayed ctx.call returns cached result\n- [ ] Non-determinism detected if target differs\n- [ ] Non-determinism detected if input differs","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:01.078286087-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.336982448-06:00","dependencies":[{"issue_id":"nuoc-ebn","depends_on_id":"nuoc-c0k","type":"blocks","created_at":"2026-01-28T07:06:54.090340561-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-eep","title":"[Proto-11] Implement replay phase in stream","description":"## Micro-task\nSend prior journal entries during replay phase.\n\n## Acceptance\n- [ ] Entries sent after StartMessage\n- [ ] Handler in replay mode\n- [ ] Transitions to processing when caught up","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:24.078224898-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.322129922-06:00","dependencies":[{"issue_id":"nuoc-eep","depends_on_id":"nuoc-c4e","type":"blocks","created_at":"2026-01-28T07:06:59.22971449-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-eml","title":"[Entity-05] Implement lock acquisition for virtual objects","description":"## Micro-task\nAcquire exclusive lock on virtual object key.\n\n## Deliverable\n\\`\\`\\`nu\nexport def vo-lock-acquire [entity: string, key: string, invocation_id: string] -\u003e bool {\n  # Try to insert lock, return false if already held\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Returns true if acquired\n- [ ] Returns false if held by another\n- [ ] Atomic operation","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:09.380177153-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.893919009-06:00","dependencies":[{"issue_id":"nuoc-eml","depends_on_id":"nuoc-p4v","type":"blocks","created_at":"2026-01-28T07:06:57.01879552-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-f2pc","title":"[Awk-05] Implement task suspension on awakeable await","description":"## Micro-task\nTask suspends when awaiting awakeable promise.\n\n## Acceptance\n- [ ] Task status -\u003e suspended\n- [ ] Worker slot freed\n- [ ] Suspension point journaled","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.876732264-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:00:27.637866467-06:00","closed_at":"2026-01-28T23:00:27.637866467-06:00","close_reason":"TDD15 complete - ctx-await-awakeable implemented and tested","dependencies":[{"issue_id":"nuoc-f2pc","depends_on_id":"nuoc-7wmq","type":"blocks","created_at":"2026-01-28T07:07:04.406350628-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-fcn","title":"[HTTP-07] Implement idempotency cache write","description":"## Micro-task\nStore response in cache after completion.\n\n## Acceptance\n- [ ] Response stored\n- [ ] expires_at = now + 24h\n- [ ] Overwrites existing","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:18.746959789-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.400718527-06:00","dependencies":[{"issue_id":"nuoc-fcn","depends_on_id":"nuoc-99c","type":"blocks","created_at":"2026-01-28T07:07:00.927696016-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-feh","title":"[Entity-10] Implement service unlimited concurrency","description":"## Micro-task\nServices have no concurrency limits - all invocations execute in parallel.\n\n## Acceptance\n- [ ] No locking for services\n- [ ] Unlimited parallel execution\n- [ ] No queuing","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:15.919346781-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.730982125-06:00","dependencies":[{"issue_id":"nuoc-feh","depends_on_id":"nuoc-uuy","type":"blocks","created_at":"2026-01-28T07:06:57.099773651-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-fgi","title":"Implement service discovery and registration endpoint","description":"## KIRK: Key Intent\nImplement Restate's service discovery protocol. Services expose a /discovery endpoint that returns a manifest of available handlers. The engine registers services by calling this endpoint.\n\n## Discovery Protocol\n- **Endpoint**: GET /discovery\n- **Content-Type**: application/vnd.restate.endpointmanifest.v1+json\n- **Returns**: Manifest with services, handlers, and protocol version\n\n## Manifest Format\n\\`\\`\\`json\n{\n  \"protocolVersion\": 1,\n  \"services\": [\n    {\n      \"name\": \"Greeter\",\n      \"type\": \"service\",\n      \"handlers\": [\n        {\"name\": \"greet\", \"input\": \"json\", \"output\": \"json\"}\n      ]\n    },\n    {\n      \"name\": \"Cart\",\n      \"type\": \"virtual_object\",\n      \"handlers\": [\n        {\"name\": \"addItem\", \"handlerType\": \"exclusive\"},\n        {\"name\": \"getItems\", \"handlerType\": \"shared\"}\n      ]\n    }\n  ]\n}\n\\`\\`\\`\n\n## EARS\n- WHEN a deployment is registered, THE SYSTEM SHALL call GET /discovery on the endpoint.\n- WHEN the manifest is returned, THE SYSTEM SHALL validate and register all services.\n- IF protocol version is unsupported, THE SYSTEM SHALL reject registration with error.\n- WHEN a service is registered, THE SYSTEM SHALL make its handlers available for invocation.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Service discovery\n\n  Scenario: Register deployment\n    Given service at http://localhost:9080\n    When \"oc deployment register http://localhost:9080\"\n    Then GET http://localhost:9080/discovery called\n    And services from manifest registered\n    And handlers available for invocation\n\n  Scenario: Invalid manifest rejected\n    Given endpoint returns malformed JSON\n    When registration attempted\n    Then error: \"invalid manifest format\"\n\n  Scenario: Protocol version mismatch\n    Given manifest with protocolVersion=99\n    When registration attempted\n    Then error: \"unsupported protocol version\"\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS deployments (\n  id TEXT PRIMARY KEY,\n  uri TEXT NOT NULL,\n  protocol_version INTEGER NOT NULL,\n  registered_at TEXT NOT NULL DEFAULT (datetime('now')),\n  last_seen_at TEXT\n);\n\nCREATE TABLE IF NOT EXISTS registered_services (\n  name TEXT PRIMARY KEY,\n  deployment_id TEXT NOT NULL,\n  service_type TEXT NOT NULL,\n  handlers TEXT NOT NULL, -- JSON array\n  FOREIGN KEY (deployment_id) REFERENCES deployments(id)\n);\n\\`\\`\\`\n\n## ATDD\n1. CLI: \\`oc deployment register \u003curi\u003e\\`\n2. Discovery endpoint called on registration\n3. Manifest validated and stored\n4. Services queryable after registration\n\n## DBC\n- **Precondition**: Endpoint is reachable\n- **Postcondition**: Services registered and invocable\n- **Invariant**: Only one registration per service name","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:52.168324654-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.872451201-06:00"}
{"id":"nuoc-fks","title":"[Lifecycle-09] Implement suspended → running transition","description":"## Micro-task\nHandler resumes when dependencies complete.\n\n## Acceptance\n- [ ] Status updated to running\n- [ ] Handler re-dispatched\n- [ ] Resumes from suspension point","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.584415081-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.467626147-06:00","dependencies":[{"issue_id":"nuoc-fks","depends_on_id":"nuoc-04t","type":"blocks","created_at":"2026-01-28T07:07:02.525144135-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-fpb","title":"[Lifecycle-12] Implement backing-off → paused transition","description":"## Micro-task\nRetry limit exceeded.\n\n## Acceptance\n- [ ] retry_count \u003e= max_retries\n- [ ] Status updated to paused\n- [ ] Requires manual intervention","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.645560798-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.42006277-06:00","dependencies":[{"issue_id":"nuoc-fpb","depends_on_id":"nuoc-qgs","type":"blocks","created_at":"2026-01-28T07:07:09.488969548-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ftb","title":"Implement OpenTelemetry observability integration","description":"## KIRK: Key Intent\nIntegrate OpenTelemetry for distributed tracing, metrics, and logging. Enables observability in production with standard tooling (Jaeger, Prometheus, Grafana). Modeled after Restate's and Temporal's observability.\n\n## EARS\n- WHEN a job starts, THE SYSTEM SHALL create a trace span with job_id as trace context.\n- WHERE tasks execute, THE SYSTEM SHALL create child spans with task name, duration, and status.\n- WHEN metrics are emitted (queue depth, retry count, duration), THE SYSTEM SHALL export them via OTLP.\n- IF OTEL_EXPORTER_OTLP_ENDPOINT is configured, THE SYSTEM SHALL send telemetry there.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: OpenTelemetry integration\n\n  Scenario: Trace spans created\n    Given job J with tasks A, B, C\n    When job executes\n    Then trace shows parent span J with child spans A, B, C\n    And each span has duration, status, attributes\n\n  Scenario: Metrics exported\n    Given Prometheus scraping /metrics endpoint\n    When jobs execute\n    Then metrics include: job_duration_seconds, task_retry_count, queue_depth\n\n  Scenario: Distributed tracing\n    Given job calls external service with trace context\n    When external service logs are correlated\n    Then they share the same trace_id\n\\`\\`\\`\n\n## ATDD\n1. Spans: job.start, job.complete, task.start, task.complete, task.retry\n2. Metrics: histograms for duration, counters for retries/failures\n3. OTLP export to configurable endpoint\n4. Trace context propagation in agent prompts\n\n## DBC\n- **Precondition**: OTEL SDK initialized at engine start\n- **Postcondition**: All job/task lifecycle events have corresponding spans\n- **Invariant**: Trace context preserved across async boundaries","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:43.912526172-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.045212039-06:00","dependencies":[{"issue_id":"nuoc-ftb","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T06:34:09.604273621-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-gby","title":"[TUI-02] Add rusqlite dependency for SQLite access","description":"## Micro-task\nAdd rusqlite and connect to journal database.\n\n## Acceptance\n- [ ] rusqlite in Cargo.toml\n- [ ] Connection to .oc-workflow/journal.db\n- [ ] Basic query works","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:19.352646243-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.383679117-06:00","dependencies":[{"issue_id":"nuoc-gby","depends_on_id":"nuoc-37v","type":"blocks","created_at":"2026-01-28T07:07:06.489746664-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-gre","title":"Move gate-check dispatch out of engine into domain-specific registry","description":"## KIRK: Key Intent\ngate-check in oc-engine.nu contains TDD15-specific logic (moon commands, Martin Fowler reviews). The engine should be domain-agnostic; gate implementations belong in oc-tdd15.nu or a gate registry.\n\n## EARS\n- WHEN the engine evaluates a gate, IT SHALL look up the gate handler from a registered gate table, not a hardcoded match block.\n- WHERE a gate is not registered, THE SYSTEM SHALL fail with \\\"unregistered gate: X\\\".\n- WHILE defining a job, the caller SHALL register gate handlers alongside task definitions.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Pluggable gate registry\n\n  Scenario: TDD15 gates registered at job creation\n    Given a TDD15 job is created\n    When gate \\\"tests_pass\\\" is evaluated\n    Then the handler from oc-tdd15.nu is invoked\n\n  Scenario: Unknown gate fails\n    Given a task with gate \\\"nonexistent_gate\\\"\n    When gate-check is called\n    Then an error is raised with \\\"unregistered gate\\\"\n\n  Scenario: Custom gate registered\n    Given a custom job registers gate \\\"custom_check\\\" with handler\n    When that gate is evaluated\n    Then the custom handler runs\n\\`\\`\\`\n\n## ATDD\n1. oc-engine.nu gate-check contains no domain-specific logic (no moon, no martin_fowler)\n2. oc-tdd15.nu exports a gate registry record\n3. Engine accepts gate registry as part of job definition or initialization\n\n## DBC\n- **Precondition**: Gate name is registered before any task referencing it executes\n- **Postcondition**: Gate evaluation delegates to registered handler\n- **Invariant**: Engine module has zero imports from domain-specific modules for gate logic\n\n## Files\n- oc-engine.nu:448-519 (gate-check — extract to registry)\n- oc-tdd15.nu (add gate-registry export)","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:23:53.818620634-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.151352405-06:00"}
{"id":"nuoc-h3f","title":"Implement HTTP Ingress layer with idempotency key routing","description":"## KIRK: Key Intent\nImplement Restate's HTTP ingress layer. This is how external clients invoke handlers. Supports idempotency keys for exactly-once, send/attach/peek patterns, and proper routing.\n\n## Endpoints (exact Restate patterns)\n\\`\\`\\`\nPOST /{ServiceName}/{handlerName}              - Invoke service\nPOST /{ObjectName}/{objectKey}/{handlerName}   - Invoke virtual object\nPOST /{WorkflowName}/{workflowId}/run          - Run workflow\nPOST /{WorkflowName}/{workflowId}/{handlerName} - Invoke workflow handler\n\nPOST /{target}/send      - Fire-and-forget (returns invocation ID)\nPOST /{target}/attach    - Attach to existing invocation (block until done)\nGET  /{target}/output    - Peek at invocation result (non-blocking)\n\\`\\`\\`\n\n## Idempotency Key Handling\n- **Header**: \\`Idempotency-Key: \u003cunique-key\u003e\\`\n- **Behavior**: \n  - Key hashes to partition\n  - If key exists: return cached response (24h retention)\n  - If new: execute and cache result\n- **Scope**: Per-service, per-handler\n\n## EARS\n- WHEN a request has Idempotency-Key header, THE SYSTEM SHALL check for cached response before executing.\n- WHEN a cached response exists for the key, THE SYSTEM SHALL return it without re-execution.\n- WHEN using /send endpoint, THE SYSTEM SHALL return immediately with {invocationId, status: \"Accepted\"}.\n- WHEN using /attach endpoint, THE SYSTEM SHALL block until the invocation completes.\n- WHEN using /output endpoint, THE SYSTEM SHALL return current result or {message: \"not ready\"}.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: HTTP Ingress\n\n  Scenario: Idempotent request\n    Given request with Idempotency-Key \"order-123\"\n    When first request executes and returns {result: \"ok\"}\n    And second request with same key arrives\n    Then {result: \"ok\"} returned without re-execution\n\n  Scenario: Fire-and-forget\n    Given POST /OrderService/process/send\n    Then response is {invocationId: \"inv_xxx\", status: \"Accepted\"}\n    And handler executes asynchronously\n\n  Scenario: Attach to invocation\n    Given invocation \"inv_xxx\" is running\n    When POST /attach with invocationId\n    Then request blocks until inv_xxx completes\n    And returns inv_xxx's result\n\n  Scenario: Peek non-blocking\n    Given invocation \"inv_xxx\" still running\n    When GET /output with invocationId\n    Then response is {message: \"not ready\"}\n    When invocation completes with {data: 123}\n    Then GET /output returns {data: 123}\n\n  Scenario: Virtual Object routing\n    Given POST /Cart/user-123/addItem\n    Then request routed to Cart virtual object with key \"user-123\"\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS idempotency_cache (\n  key_hash TEXT NOT NULL,\n  service_name TEXT NOT NULL,\n  handler_name TEXT NOT NULL,\n  invocation_id TEXT NOT NULL,\n  response BLOB,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  expires_at TEXT NOT NULL,\n  PRIMARY KEY (key_hash, service_name, handler_name)\n);\nCREATE INDEX idx_idempotency_expires ON idempotency_cache(expires_at);\n\\`\\`\\`\n\n## ATDD\n1. HTTP server listens on configurable port (default 8080)\n2. All endpoint patterns work correctly\n3. Idempotency cache has 24h TTL (configurable)\n4. Content-Type: application/json for all responses\n\n## DBC\n- **Precondition**: Service/handler registered\n- **Postcondition**: Invocation created or cached response returned\n- **Invariant**: Same idempotency key always returns same response within TTL","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:59:00.209807041-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.552182566-06:00"}
{"id":"nuoc-hdu","title":"[Replay-17] Implement journal corruption detection with checksums","description":"## Micro-task\nEach journal entry has checksum. Detect corruption on read.\n\n## Deliverable\n- Add checksum column to journal table\n- Compute checksum on write\n- Verify checksum on read\n\n## Acceptance\n- [ ] Corrupted entries detected\n- [ ] Clear error with entry_index\n- [ ] Job fails gracefully on corruption","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:11.021101894-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.812737902-06:00","dependencies":[{"issue_id":"nuoc-hdu","depends_on_id":"nuoc-m8e","type":"blocks","created_at":"2026-01-28T07:06:54.23104558-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ie1","title":"[Ctx-17] Implement ctx.promise for workflow promises","description":"## Micro-task\nImplement ctx.promise(key) to get or create durable promise.\n\n## Acceptance\n- [ ] Returns promise that blocks until completed\n- [ ] Scoped to workflow instance\n- [ ] Multiple callers wait on same promise","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:01:57.564934981-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.662861164-06:00","dependencies":[{"issue_id":"nuoc-ie1","depends_on_id":"nuoc-1zd","type":"blocks","created_at":"2026-01-28T07:07:02.240013966-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-iii","title":"Add agent session cleanup to prevent orphaned opencode sessions","description":"## KIRK: Key Intent\nrun-task creates an opencode session per task execution but never closes or cleans up sessions. Over a 16-phase job with retries, dozens of orphaned sessions accumulate.\n\n## EARS\n- WHEN a task completes (COMPLETED, FAILED, or SKIPPED), THE SYSTEM SHALL close or terminate its associated opencode session.\n- IF a job is cancelled, THE SYSTEM SHALL abort all active sessions for that job.\n- WHERE a task retries, THE SYSTEM SHALL reuse or close the prior session before creating a new one.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Session lifecycle management\n\n  Scenario: Session closed on task completion\n    Given task \\\"red\\\" creates session S1\n    When task \\\"red\\\" completes\n    Then session S1 is closed via oc-abort or equivalent\n\n  Scenario: Job cancellation aborts all sessions\n    Given job J has 3 tasks with active sessions\n    When job-cancel is called for J\n    Then all 3 sessions are aborted\n\n  Scenario: Retry closes old session\n    Given task \\\"green\\\" fails on attempt 1 with session S1\n    When attempt 2 begins\n    Then S1 is closed before S2 is created\n\\`\\`\\`\n\n## ATDD\n1. After job-execute completes, zero active sessions remain for that job\n2. Session IDs are tracked in tasks table (add session_id column)\n3. job-cancel calls oc-abort for all RUNNING task sessions\n\n## DBC\n- **Precondition**: opencode server is reachable\n- **Postcondition**: Every created session is eventually closed\n- **Invariant**: Active session count \u003c= number of RUNNING tasks at any point\n\n## Files\n- oc-engine.nu:334-376 (run-task — add session tracking and cleanup)\n- oc-agent.nu:105-108 (oc-abort)\n- oc-engine.nu:542-546 (job-cancel — add session abort)","status":"open","priority":2,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:24:43.8471873-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.131392733-06:00","dependencies":[{"issue_id":"nuoc-iii","depends_on_id":"nuoc-3cd","type":"blocks","created_at":"2026-01-28T02:24:58.674490915-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ima","title":"Implement task queue worker model with poll-based dispatch","description":"## KIRK: Key Intent\nDecouple orchestration from execution. The engine should dispatch tasks to queues; workers poll for work. This enables horizontal scaling, heterogeneous workers (different agent types on different machines), and backpressure. Modeled after Temporal's worker/task-queue architecture and Hatchet's slot-based workers.\n\n## EARS\n- WHEN a task becomes ready, THE SYSTEM SHALL enqueue it to the appropriate task queue based on task type (agent, shell, gate).\n- WHEN a worker has available slots, IT SHALL poll its registered task queue and claim a task atomically.\n- IF a worker crashes while holding a task, THE SYSTEM SHALL detect via heartbeat timeout and re-enqueue the task.\n- WHERE multiple workers poll the same queue, THE SYSTEM SHALL distribute tasks fairly (round-robin or least-loaded).\n- WHILE a worker is at capacity (all slots full), IT SHALL NOT claim additional tasks.\n\n## BDD Scenarios\n```gherkin\nFeature: Task queue worker model\n\n  Scenario: Task dispatched to queue\n    Given task \"red\" becomes ready with agent_type \"general-purpose\"\n    When the scheduler runs\n    Then task \"red\" appears in queue \"agent:general-purpose\"\n\n  Scenario: Worker claims task\n    Given worker W1 has 3/5 slots used and polls queue \"agent:general-purpose\"\n    When task \"red\" is in the queue\n    Then W1 claims \"red\" atomically and slot count becomes 4/5\n\n  Scenario: Worker crash re-enqueues task\n    Given worker W1 claimed task \"red\" and last heartbeat was 60s ago\n    And heartbeat timeout is 30s\n    When the reaper runs\n    Then task \"red\" is re-enqueued\n    And W1's claim is released\n\n  Scenario: Backpressure when workers full\n    Given all workers have 5/5 slots used\n    When task \"green\" becomes ready\n    Then \"green\" remains in queue until a slot opens\n```\n\n## ATDD\n1. Tasks never execute in the engine process — always dispatched to workers\n2. Worker heartbeat tracked in DB; stale claims reaped\n3. Multiple workers can process same queue concurrently without double-dispatch\n4. Queue depth observable via status command\n\n## DBC\n- **Precondition**: At least one worker registered for each task type\n- **Postcondition**: Every enqueued task is eventually claimed or times out\n- **Invariant**: A task is claimed by at most one worker at any time\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS task_queues (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  queue_name TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'QUEUED',\n  claimed_by TEXT,\n  claimed_at TEXT,\n  heartbeat_at TEXT,\n  enqueued_at TEXT NOT NULL DEFAULT (datetime('now')),\n  UNIQUE (job_id, task_name)\n);\nCREATE TABLE IF NOT EXISTS workers (\n  id TEXT PRIMARY KEY,\n  queues TEXT NOT NULL,\n  max_slots INTEGER NOT NULL DEFAULT 5,\n  active_slots INTEGER NOT NULL DEFAULT 0,\n  last_heartbeat TEXT NOT NULL DEFAULT (datetime('now')),\n  registered_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n```","notes":"## Additional Edge Case Scenarios\n```gherkin\n  Scenario: Worker reconnects after network partition\n    Given worker W1 was partitioned for 45s (heartbeat timeout 30s)\n    And its tasks were re-enqueued to W2\n    When W1 reconnects\n    Then W1 discovers its claims were revoked\n    And W1 does not duplicate work W2 completed\n\n  Scenario: Queue draining for graceful shutdown\n    Given worker W1 has 3 active tasks\n    When W1 receives SIGTERM\n    Then W1 stops accepting new tasks\n    And W1 completes in-flight tasks (up to drain timeout)\n    And W1 releases incomplete tasks back to queue\n\n  Scenario: Priority queue ordering\n    Given tasks T1(priority=1), T2(priority=3), T3(priority=2) in queue\n    When worker polls\n    Then T2 is claimed first (highest priority)\n    Then T3, then T1\n\n  Scenario: Dead letter queue for poison tasks\n    Given task T fails 5 times (max_attempts=5)\n    When final retry fails\n    Then T is moved to dead letter queue\n    And alert is emitted\n    And T does not block other tasks\n```","status":"closed","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:40.520922245-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:09:51.823806938-06:00","closed_at":"2026-01-29T05:09:51.823809918-06:00","dependencies":[{"issue_id":"nuoc-ima","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.369659601-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-iol","title":"[Replay-01] Design journal table schema with entry_index, op_type, input_hash","description":"## Micro-task\nCreate the journal table schema that replaces the events table.\n\n## Deliverable\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS journal (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  task_name TEXT NOT NULL,\n  attempt INTEGER NOT NULL DEFAULT 1,\n  entry_index INTEGER NOT NULL,\n  op_type TEXT NOT NULL,\n  input_hash TEXT,\n  input TEXT,\n  output TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  UNIQUE (job_id, task_name, attempt, entry_index)\n);\nCREATE INDEX idx_journal_replay ON journal(job_id, task_name, attempt);\n\\`\\`\\`\n\n## Acceptance\n- [ ] Schema created in db-init\n- [ ] Unique constraint on (job_id, task_name, attempt, entry_index)\n- [ ] Index for replay queries","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:02.502782482-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.27287954-06:00"}
{"id":"nuoc-j14","title":"[Lifecycle-01] Add status enum with 8 states to jobs table","description":"## Micro-task\nUpdate jobs table status to support all 8 states.\n\n## States\npending, scheduled, ready, running, suspended, backing-off, paused, completed\n\n## Acceptance\n- [ ] All 8 states valid in status column\n- [ ] Existing code handles new states\n- [ ] Migration for existing data","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.422081199-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.598627196-06:00"}
{"id":"nuoc-j8c","title":"[Replay-13] Implement journal truncation on new attempt","description":"## Micro-task\nWhen a new attempt starts after failure, previous attempt's incomplete entries are not carried over.\n\n## Deliverable\nEach attempt has its own journal entries (attempt column differentiates).\n\n## Acceptance\n- [ ] Attempt 2 starts with empty journal\n- [ ] Attempt 1 entries remain for debugging\n- [ ] known_entries=0 for new attempt","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:05.690760916-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.105112519-06:00","dependencies":[{"issue_id":"nuoc-j8c","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:54.151792258-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-jtr","title":"[Proto-03] Implement StartMessage structure","description":"## Micro-task\nStartMessage with all fields.\n\n## Fields\n- id: invocation ID\n- debug_id: human readable\n- known_entries: journal length\n- state_map: eager state\n- partial_state: bool\n- random_seed: for deterministic RNG\n\n## Acceptance\n- [ ] All fields defined\n- [ ] Serialization to JSON/binary\n- [ ] Deserialization works","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:13.698016332-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.453503291-06:00","dependencies":[{"issue_id":"nuoc-jtr","depends_on_id":"nuoc-43v","type":"blocks","created_at":"2026-01-28T07:06:59.066982465-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ks6","title":"[TUI-07] Query tasks for selected job","description":"## Micro-task\nLoad tasks and dependencies for selected job.\n\n## Acceptance\n- [ ] All tasks for job loaded\n- [ ] Dependencies from task_deps loaded\n- [ ] Task status parsed","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:26.755937039-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.222174673-06:00","dependencies":[{"issue_id":"nuoc-ks6","depends_on_id":"nuoc-n5m","type":"blocks","created_at":"2026-01-28T07:07:06.59206071-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-kuy","title":"[Lifecycle-04] Add next_retry_at and retry tracking columns","description":"## Micro-task\nTrack retry scheduling for backing-off state.\n\n## Columns\n- next_retry_at: when to retry\n- retry_count: number of retries so far\n- last_failure: error message\n- last_failure_code: error code\n\n## Acceptance\n- [ ] Columns added\n- [ ] Updated on each retry\n- [ ] Cleared on success","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.482013792-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.549806902-06:00","dependencies":[{"issue_id":"nuoc-kuy","depends_on_id":"nuoc-j14","type":"blocks","created_at":"2026-01-28T07:07:02.423481012-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-l4d","title":"[Awk-02] Implement awakeable ID generation","description":"## Micro-task\nGenerate ID in Restate format: prom_1 + base64url(invocation_id + entry_index)\n\n## Acceptance\n- [ ] Prefix is 'prom_1'\n- [ ] Base64-URL encoding\n- [ ] Globally unique","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.811510347-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:00:11.856480119-06:00","closed_at":"2026-01-28T23:00:11.856480119-06:00","close_reason":"TDD15 complete - awakeable-id-generate implemented and tested","dependencies":[{"issue_id":"nuoc-l4d","depends_on_id":"nuoc-9w6","type":"blocks","created_at":"2026-01-28T07:07:04.345800998-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-l71","title":"[Lifecycle-03] Add completion_result and completion_failure columns","description":"## Micro-task\nTrack whether completion was success or failure with details.\n\n## Acceptance\n- [ ] completion_result: 'success' | 'failure'\n- [ ] completion_failure: error details JSON\n- [ ] Set on transition to completed","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.463294971-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.565825004-06:00","dependencies":[{"issue_id":"nuoc-l71","depends_on_id":"nuoc-j14","type":"blocks","created_at":"2026-01-28T07:07:02.405345831-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-lfe","title":"[Ctx-18] Implement ctx.peek for non-blocking promise check","description":"## Micro-task\nImplement ctx.peek(key) to check promise status without blocking.\n\n## Acceptance\n- [ ] Returns value if completed\n- [ ] Returns null if pending\n- [ ] Never blocks","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:01:58.491976596-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.646596742-06:00","dependencies":[{"issue_id":"nuoc-lfe","depends_on_id":"nuoc-ie1","type":"blocks","created_at":"2026-01-28T07:07:02.26117443-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-lie","title":"Implement namespace/multi-tenancy isolation","description":"## KIRK: Key Intent\nIsolate workflows by namespace for multi-tenant deployments. Each namespace has its own jobs, workers, and quotas. Enables SaaS deployments and team isolation. Modeled after Temporal's namespaces and Hatchet's tenants.\n\n## EARS\n- WHEN a job is created, THE SYSTEM SHALL assign it to a namespace (default: \"default\").\n- WHERE workers register, THEY SHALL specify which namespace(s) they serve.\n- IF a worker polls a queue, THE SYSTEM SHALL only return tasks from its registered namespaces.\n- WHEN quotas are configured per namespace, THE SYSTEM SHALL enforce rate limits and concurrency limits per namespace.\n- WHERE a namespace is deleted, THE SYSTEM SHALL cancel all jobs and archive data.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Multi-tenancy\n\n  Scenario: Jobs isolated by namespace\n    Given namespace \"tenant-a\" has job J1\n    And namespace \"tenant-b\" has job J2\n    When querying jobs in \"tenant-a\"\n    Then only J1 is returned\n\n  Scenario: Workers scoped to namespace\n    Given worker W1 registered for namespace \"tenant-a\"\n    When task T2 is queued in namespace \"tenant-b\"\n    Then W1 does not receive T2\n\n  Scenario: Per-namespace rate limits\n    Given namespace \"tenant-a\" has rate_limit=10/min\n    When 11th job starts in \"tenant-a\"\n    Then it is queued until rate limit resets\n\\`\\`\\`\n\n## ATDD\n1. namespace column on jobs, task_queues, workers\n2. CLI: \\`oc --namespace=X job create ...\\`\n3. HTTP: X-Namespace header or /namespaces/:ns/... routes\n4. Quota configuration per namespace\n\n## DBC\n- **Precondition**: Namespace exists before jobs created in it\n- **Postcondition**: All resources tagged with namespace\n- **Invariant**: Cross-namespace access requires explicit permission\n\n## Schema Addition\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS namespaces (\n  name TEXT PRIMARY KEY,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  config TEXT\n);\nALTER TABLE jobs ADD COLUMN namespace TEXT NOT NULL DEFAULT 'default';\nALTER TABLE workers ADD COLUMN namespaces TEXT NOT NULL DEFAULT 'default';\n\\`\\`\\`","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:47.488379313-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.907033669-06:00","dependencies":[{"issue_id":"nuoc-lie","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T06:34:09.510623107-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ltc","title":"[Ctx-03] Implement ctx.clear for state deletion","description":"## Micro-task\nImplement ctx.clear(key) to delete a state key.\n\n## Acceptance\n- [ ] Key removed from keyed_state\n- [ ] Operation journaled\n- [ ] Idempotent on replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:03.546425343-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.208224664-06:00","dependencies":[{"issue_id":"nuoc-ltc","depends_on_id":"nuoc-as3","type":"blocks","created_at":"2026-01-28T07:06:56.128735897-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-lz7","title":"[Lifecycle-07] Implement ready → running transition","description":"## Micro-task\nWorker picks up ready invocation.\n\n## Acceptance\n- [ ] Status updated to running\n- [ ] running_at timestamp set\n- [ ] Worker claims invocation","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.543973579-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.501328567-06:00","dependencies":[{"issue_id":"nuoc-lz7","depends_on_id":"nuoc-3ze","type":"blocks","created_at":"2026-01-28T07:07:02.484995289-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-lzx","title":"Implement invocation management — cancel, kill, resume, purge","description":"## KIRK: Key Intent\nImplement Restate's invocation management operations: cancel (cooperative), kill (forceful), resume (restart paused), and purge (cleanup completed).\n\n## Operations\n\n### Cancel (cooperative)\n- Triggers cancellation exceptions at await points\n- Allows handler to run cleanup/compensation\n- Requires accessible deployment\n- Non-blocking operation\n\n### Kill (forceful)\n- Immediately terminates invocation tree\n- No cleanup code executed\n- Last resort when endpoints unreachable\n\n### Resume\n- Restarts paused invocations\n- Can override deployment\n- Useful after fixing bugs\n\n### Purge\n- Removes completed invocations\n- Frees storage after retention\n- Removes from introspection tables\n\n## EARS\n- WHEN cancel is requested, THE SYSTEM SHALL set cancellation flag and wake suspended handlers.\n- WHEN a cancelled handler reaches an await point, IT SHALL throw CancellationException.\n- WHEN kill is requested, THE SYSTEM SHALL immediately terminate without running handler code.\n- WHEN resume is requested for paused invocation, THE SYSTEM SHALL transition to running.\n- WHEN purge is requested for completed invocation, THE SYSTEM SHALL delete all related data.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Invocation management\n\n  Scenario: Cooperative cancellation\n    Given invocation inv_123 is running\n    When cancel(inv_123) is called\n    Then cancellation flag set\n    When handler reaches ctx.sleep()\n    Then CancellationException thrown\n    And handler can run cleanup\n\n  Scenario: Kill terminates immediately\n    Given invocation inv_123 is running\n    When kill(inv_123) is called\n    Then invocation immediately marked KILLED\n    And no handler code runs\n\n  Scenario: Resume paused invocation\n    Given invocation inv_123 is paused (retry limit)\n    When resume(inv_123) is called\n    Then invocation transitions to running\n    And execution continues\n\n  Scenario: Purge removes data\n    Given invocation inv_123 completed 30 days ago\n    When purge(inv_123) is called\n    Then journal entries deleted\n    And invocation removed from sys_invocation\n\\`\\`\\`\n\n## CLI Commands\n\\`\\`\\`\noc invocation cancel \u003cid\u003e\noc invocation kill \u003cid\u003e\noc invocation resume \u003cid\u003e [--deployment \u003curi\u003e]\noc invocation purge \u003cid\u003e\noc invocation purge --before \u003ctimestamp\u003e\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nALTER TABLE jobs ADD COLUMN cancellation_requested INTEGER DEFAULT 0;\nALTER TABLE jobs ADD COLUMN killed_at TEXT;\n\\`\\`\\`\n\n## ATDD\n1. Cancel sets flag and wakes suspended handlers\n2. Kill immediately terminates without cleanup\n3. Resume only works for paused invocations\n4. Purge removes all traces of invocation\n\n## DBC\n- **Precondition**: Invocation exists\n- **Postcondition**: Invocation state updated appropriately\n- **Invariant**: Killed invocations never run handler code","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:55.148889395-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.569190205-06:00"}
{"id":"nuoc-m5uj","title":"[Worker-05] Implement task enqueueing","description":"## Micro-task\nAdd ready task to appropriate queue.\n\n## Acceptance\n- [ ] Queue name derived from task type\n- [ ] Status = QUEUED\n- [ ] enqueued_at set","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.953081123-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.951223049-06:00","dependencies":[{"issue_id":"nuoc-m5uj","depends_on_id":"nuoc-bxis","type":"blocks","created_at":"2026-01-28T07:07:02.581577674-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-m6s","title":"[Proto-05] Implement SuspensionMessage structure","description":"## Micro-task\nSuspensionMessage listing awaited entries.\n\n## Fields\n- entry_indexes: list of pending entries\n\n## Acceptance\n- [ ] Struct defined\n- [ ] Multiple indexes supported\n- [ ] Sent when handler suspends","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:16.873306554-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.42013895-06:00","dependencies":[{"issue_id":"nuoc-m6s","depends_on_id":"nuoc-43v","type":"blocks","created_at":"2026-01-28T07:06:59.107530606-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-m8e","title":"[Replay-02] Implement journal-write command for appending entries","description":"## Micro-task\nCreate nushell command to append a journal entry atomically.\n\n## Deliverable\n\\`\\`\\`nu\nexport def journal-write [\n  job_id: string,\n  task_name: string,\n  attempt: int,\n  entry_index: int,\n  op_type: string,\n  input: any,\n  output: any\n] {\n  let input_json = (\\$input | to json -r)\n  let output_json = (\\$output | to json -r)\n  let input_hash = (\\$input_json | hash sha256)\n  sql-exec \\$\"INSERT INTO journal (...) VALUES (...)\"\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Entry persisted atomically\n- [ ] input_hash computed from input\n- [ ] Returns entry_index on success","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:02.966856558-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.239902088-06:00","dependencies":[{"issue_id":"nuoc-m8e","depends_on_id":"nuoc-iol","type":"blocks","created_at":"2026-01-28T07:06:53.92756801-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-mgs","title":"[TUI-14] Implement cancel job action","description":"## Micro-task\n'c' key cancels selected job with confirmation.\n\n## Acceptance\n- [ ] Confirmation prompt shown\n- [ ] job-cancel called\n- [ ] UI updates immediately","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:36.880760554-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.098363408-06:00","dependencies":[{"issue_id":"nuoc-mgs","depends_on_id":"nuoc-n5m","type":"blocks","created_at":"2026-01-28T07:07:06.749015468-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-mnw","title":"Implement 8-state invocation lifecycle — exact Restate state machine","description":"## KIRK: Key Intent\nImplement Restate's exact 8-state invocation lifecycle: pending, scheduled, ready, running, suspended, backing-off, paused, completed. Our current engine only has PENDING, RUNNING, COMPLETED, FAILED, CANCELLED.\n\n## States (exact Restate)\n\n1. **pending**: Initial state after creation\n2. **scheduled**: Awaiting scheduled start time (delayed invocation)\n3. **ready**: Prepared for execution, queued for processor\n4. **running**: Active execution, journal entries being appended\n5. **suspended**: Blocked awaiting external dependencies\n6. **backing-off**: Retrying after failure, waiting for next_retry_at\n7. **paused**: Manually halted or retry limit exceeded\n8. **completed**: Finished (success or failure in completion_result)\n\n## State Transitions\n\\`\\`\\`\nEntry:\n  pending → ready         (processor acknowledges)\n  pending → scheduled     (delay specified)\n  scheduled → ready       (scheduled_start_at reached)\n\nExecution:\n  ready → running         (processor picks up)\n  running → completed     (EndMessage received)\n  running → suspended     (awaiting dependencies)\n  running → backing-off   (failure with retry remaining)\n\nRecovery:\n  suspended → running     (dependencies completed)\n  backing-off → running   (next_retry_at reached)\n  paused → running        (manual resume)\n\nFailure:\n  running → backing-off   (retriable failure)\n  backing-off → paused    (retry limit exceeded)\n  backing-off → completed (non-retriable failure)\n\\`\\`\\`\n\n## EARS\n- WHEN an invocation is created, IT SHALL start in pending state.\n- WHEN an invocation has invoke_time set, IT SHALL transition to scheduled until that time.\n- WHEN an invocation awaits awakeables/calls/promises, IT SHALL transition to suspended.\n- WHEN an invocation fails with retries remaining, IT SHALL transition to backing-off with next_retry_at.\n- WHEN retry limit exceeded, IT SHALL transition to paused requiring manual intervention.\n- WHEN completed, THE SYSTEM SHALL record completion_result as 'success' or 'failure'.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: 8-state lifecycle\n\n  Scenario: Delayed invocation\n    Given invocation with delay=60s\n    Then state is 'scheduled' with scheduled_start_at\n    When 60s passes\n    Then state transitions to 'ready'\n\n  Scenario: Suspension on awakeable\n    Given invocation running and calls ctx.awakeable()\n    When promise is awaited\n    Then state is 'suspended'\n    When awakeable resolved\n    Then state returns to 'running'\n\n  Scenario: Retry with backoff\n    Given invocation fails on attempt 1\n    And max_attempts=3\n    Then state is 'backing-off' with next_retry_at\n    When next_retry_at reached\n    Then state returns to 'running' for attempt 2\n\n  Scenario: Pause after retry exhaustion\n    Given invocation exhausted 3 retries\n    Then state is 'paused'\n    And requires manual intervention\n    When operator calls resume\n    Then state returns to 'running'\n\\`\\`\\`\n\n## Schema Update\n\\`\\`\\`sql\n-- Expand status enum\n-- Old: PENDING, RUNNING, COMPLETED, FAILED, CANCELLED, SKIPPED\n-- New: pending, scheduled, ready, running, suspended, backing-off, paused, completed\n\nALTER TABLE jobs ADD COLUMN scheduled_start_at TEXT;\nALTER TABLE jobs ADD COLUMN completion_result TEXT; -- 'success' | 'failure'\nALTER TABLE jobs ADD COLUMN completion_failure TEXT; -- error details if failure\nALTER TABLE jobs ADD COLUMN next_retry_at TEXT;\nALTER TABLE jobs ADD COLUMN retry_count INTEGER DEFAULT 0;\nALTER TABLE jobs ADD COLUMN last_failure TEXT;\nALTER TABLE jobs ADD COLUMN last_failure_code INTEGER;\n\\`\\`\\`\n\n## ATDD\n1. All 8 states reachable and observable in job-status\n2. Transitions match Restate's exact state machine\n3. Manual resume works for paused invocations\n4. Scheduled invocations fire at correct time\n\n## DBC\n- **Precondition**: Current state allows transition\n- **Postcondition**: State recorded with timestamp\n- **Invariant**: Only valid transitions allowed per state machine","status":"in_progress","priority":0,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:53.994079126-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T06:56:44.197830571-06:00"}
{"id":"nuoc-n4w","title":"Add idempotency keys and event-sourced replay for Restate-style durability","description":"## KIRK: Key Intent\nThe events table is an audit log, not a source of truth. For true Restate-style durable execution, state must be reconstructable from the event log. Tasks need idempotency keys so replayed operations produce identical results.\n\n## EARS\n- WHEN a task is executed, THE SYSTEM SHALL record the full input+output in the events table as the authoritative record.\n- IF the engine crashes and resumes, THE SYSTEM SHALL reconstruct task state from events, not just from the tasks table status column.\n- WHERE a task has an idempotency key (job_id + task_name + attempt), THE SYSTEM SHALL skip re-execution if an event with matching key and COMPLETED status exists.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Event-sourced replay\n\n  Scenario: State reconstructed from events after crash\n    Given job J ran tasks A (COMPLETED) and B (RUNNING) before crash\n    And events table has COMPLETED event for A with output\n    When job-resume reconstructs state\n    Then task A output is restored from events\n    And task B is reset to PENDING\n\n  Scenario: Idempotent replay skips completed work\n    Given task A has event (job_id=J, task=A, attempt=1, type=task.Completed)\n    When job-execute encounters task A\n    Then it skips execution and uses the recorded output\n\n  Scenario: Replay produces same result\n    Given a deterministic task with known input\n    When executed twice with same idempotency key\n    Then the output is identical both times\n\\`\\`\\`\n\n## ATDD\n1. After crash simulation (kill process, restart), job-resume produces identical end state\n2. Events table contains sufficient data to reconstruct full task state\n3. Idempotency key (job_id, task_name, attempt) is unique in events\n\n## DBC\n- **Precondition**: Events table has all state transitions recorded\n- **Postcondition**: reconstructed state from events matches tasks table state\n- **Invariant**: events table is append-only; tasks table is a materialized view of events\n\n## Files\n- oc-engine.nu:69-78 (events schema — add input/output/idempotency columns)\n- oc-engine.nu:119-129 (emit-event — enhance payload)\n- oc-engine.nu:244-256 (job-resume — add event replay)\n- oc-engine.nu:259-331 (task-execute — add idempotency check)","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:24:43.867235575-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.113623825-06:00","dependencies":[{"issue_id":"nuoc-n4w","depends_on_id":"nuoc-0zq","type":"blocks","created_at":"2026-01-28T02:24:58.636764368-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-n4w","depends_on_id":"nuoc-iii","type":"blocks","created_at":"2026-01-28T02:24:58.65575505-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-n4w","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.349840336-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-n5m","title":"[TUI-06] Implement keyboard navigation for job list","description":"## Micro-task\nArrow keys to navigate job list.\n\n## Keys\n- Up/k: previous job\n- Down/j: next job\n- Enter: view job details\n- q: quit\n\n## Acceptance\n- [ ] Navigation works\n- [ ] Selection wraps at edges\n- [ ] Enter opens DAG view","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:25.964710307-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.238303474-06:00","dependencies":[{"issue_id":"nuoc-n5m","depends_on_id":"nuoc-7gk","type":"blocks","created_at":"2026-01-28T07:07:06.570093925-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-n686","title":"[Awk-07] Implement HTTP endpoint for awakeable resolution","description":"## Micro-task\nPOST /awakeables/{id}/resolve endpoint.\n\n## Acceptance\n- [ ] Accepts JSON payload\n- [ ] Returns success/error\n- [ ] Task woken","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.911576684-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.194806483-06:00","dependencies":[{"issue_id":"nuoc-n686","depends_on_id":"nuoc-a7ti","type":"blocks","created_at":"2026-01-28T07:07:04.449229761-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-n8o","title":"Implement workflow signals — async fire-and-forget messages to running workflows","description":"## KIRK: Key Intent\nEnable external systems to send async messages to running workflows without blocking. Unlike awakeables (which suspend waiting for resolution), signals are fire-and-forget and processed when the workflow is ready. Modeled after Temporal's signals.\n\n## EARS\n- WHEN a signal is sent to a job, THE SYSTEM SHALL enqueue it and return immediately (no blocking).\n- WHEN the workflow reaches a signal-check point, IT SHALL process all pending signals in order received.\n- IF a workflow is suspended, THE SYSTEM SHALL queue signals until it resumes.\n- WHERE a signal handler is defined, THE SYSTEM SHALL invoke it with the signal payload.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Workflow signals\n\n  Scenario: Signal queued and processed\n    Given job J is running task T1\n    When signal \"cancel-requested\" is sent to J\n    Then signal is queued\n    When T1 completes and workflow checks signals\n    Then \"cancel-requested\" handler is invoked\n\n  Scenario: Multiple signals processed in order\n    Given signals S1, S2, S3 sent in that order\n    When workflow processes signals\n    Then they are handled in order S1, S2, S3\n\n  Scenario: Signal to suspended workflow\n    Given job J is suspended on awakeable\n    When signal \"priority-boost\" is sent\n    Then signal is queued\n    When J resumes\n    Then signal is processed\n\\`\\`\\`\n\n## ATDD\n1. CLI: \\`oc signal send \u003cjob_id\u003e \u003csignal_name\u003e --payload \u003cjson\u003e\\`\n2. HTTP: POST /jobs/:id/signals\n3. Signal handlers defined in workflow definition\n4. Signals survive crash (persisted before ack)\n\n## DBC\n- **Precondition**: Job exists and is not COMPLETED/CANCELLED\n- **Postcondition**: Signal is persisted and eventually processed\n- **Invariant**: Signals processed exactly once in FIFO order","notes":"## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS signals (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  job_id TEXT NOT NULL,\n  signal_name TEXT NOT NULL,\n  payload TEXT,\n  status TEXT NOT NULL DEFAULT 'PENDING',\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  processed_at TEXT\n);\nCREATE INDEX idx_signal_job ON signals(job_id, status);\n\n-- Signal handlers registered per workflow\nCREATE TABLE IF NOT EXISTS signal_handlers (\n  workflow_name TEXT NOT NULL,\n  signal_name TEXT NOT NULL,\n  handler_task TEXT NOT NULL,\n  PRIMARY KEY (workflow_name, signal_name)\n);\n```","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.143090655-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.637609102-06:00","dependencies":[{"issue_id":"nuoc-n8o","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.289292225-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-o0n","title":"[HTTP-02] Implement route parsing for service invocations","description":"## Micro-task\nParse URL path to extract service/handler.\n\n## Routes\n- /{ServiceName}/{handlerName}\n- /{ObjectName}/{key}/{handlerName}\n- /{WorkflowName}/{id}/run\n\n## Acceptance\n- [ ] All patterns parsed\n- [ ] Entity type detected\n- [ ] Key/ID extracted","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:12.968631019-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.502016845-06:00","dependencies":[{"issue_id":"nuoc-o0n","depends_on_id":"nuoc-3h1","type":"blocks","created_at":"2026-01-28T07:07:00.847992609-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-o6a","title":"[Lifecycle-10] Implement running → backing-off transition","description":"## Micro-task\nHandler fails with retries remaining.\n\n## Acceptance\n- [ ] Status updated to backing-off\n- [ ] next_retry_at calculated with backoff\n- [ ] retry_count incremented","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.604491184-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.451466206-06:00","dependencies":[{"issue_id":"nuoc-o6a","depends_on_id":"nuoc-lz7","type":"blocks","created_at":"2026-01-28T07:07:02.543422174-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-p4v","title":"[Entity-04] Create virtual_object_locks table","description":"## Micro-task\nSchema for single-writer locks on virtual object keys.\n\n## Deliverable\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS virtual_object_locks (\n  entity_name TEXT NOT NULL,\n  object_key TEXT NOT NULL,\n  holder_invocation_id TEXT,\n  acquired_at TEXT,\n  PRIMARY KEY (entity_name, object_key)\n);\n\\`\\`\\`\n\n## Acceptance\n- [ ] Table created\n- [ ] Primary key on (entity_name, object_key)\n- [ ] Holder tracking","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:08.116985328-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.941819896-06:00"}
{"id":"nuoc-pay","title":"[Replay-16] Handle large outputs with chunked journaling","description":"## Micro-task\nOutputs larger than 1MB should be chunked into multiple journal entries.\n\n## Deliverable\n- Detect large output\n- Split into chunks with chunk_index\n- Reassemble on replay\n\n## Acceptance\n- [ ] Outputs up to 10MB supported\n- [ ] Chunking transparent to caller\n- [ ] Chunks reassembled correctly","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:09.438250803-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.877131429-06:00","dependencies":[{"issue_id":"nuoc-pay","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:54.21281799-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-pciq","title":"[Worker-11] Implement worker slot checking before claim","description":"## Micro-task\nWorker only claims if active_slots \u003c max_slots.\n\n## Acceptance\n- [ ] No claim if at capacity\n- [ ] Backpressure works\n- [ ] Slot count accurate","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.074558317-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.850751337-06:00","dependencies":[{"issue_id":"nuoc-pciq","depends_on_id":"nuoc-w3fm","type":"blocks","created_at":"2026-01-28T07:07:02.730636055-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ph8","title":"[HTTP-08] Implement synchronous invoke endpoint","description":"## Micro-task\nPOST /{target} blocks until completion.\n\n## Acceptance\n- [ ] Creates invocation\n- [ ] Waits for completion\n- [ ] Returns result as JSON","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:19.725062916-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.368171885-06:00","dependencies":[{"issue_id":"nuoc-ph8","depends_on_id":"nuoc-fcn","type":"blocks","created_at":"2026-01-28T07:07:00.951504589-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-pjh","title":"[Proto-09] Implement message deserialization","description":"## Micro-task\nParse messages from binary stream.\n\n## Acceptance\n- [ ] Header parsed\n- [ ] Message type identified\n- [ ] Payload deserialized","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:21.032853181-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.356471961-06:00","dependencies":[{"issue_id":"nuoc-pjh","depends_on_id":"nuoc-csp","type":"blocks","created_at":"2026-01-28T07:06:59.190295976-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-pvb2","title":"[Awk-03] Implement awakeable ID parsing","description":"## Micro-task\nParse ID back to invocation + entry_index.\n\n## Acceptance\n- [ ] Extract invocation_id\n- [ ] Extract entry_index\n- [ ] Error on invalid format","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.834298256-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:00:21.662556977-06:00","closed_at":"2026-01-28T23:00:21.662556977-06:00","close_reason":"TDD15 complete - awakeable-id-parse implemented and tested","dependencies":[{"issue_id":"nuoc-pvb2","depends_on_id":"nuoc-l4d","type":"blocks","created_at":"2026-01-28T07:07:04.367743503-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-pxx","title":"Replace string-matching gates with structured JSON verdict parsing","description":"## KIRK: Key Intent\nGate evaluation checks for substring presence in free-form LLM output (e.g. str contains \\\"pass\\\"). This produces false positives/negatives. Gates must require and parse structured JSON verdicts.\n\n## EARS\n- WHEN an agent task completes, THE SYSTEM SHALL extract a JSON object matching schema {\\\"verdict\\\": \\\"PASS|FAIL\\\", \\\"issues\\\": [...]} from the output.\n- IF the output does not contain valid verdict JSON, THEN the gate SHALL fail with reason \\\"no structured verdict found\\\".\n- WHERE a gate evaluates agent output, IT SHALL NOT use substring matching on natural language.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Structured gate verdicts\n\n  Scenario: Valid PASS verdict parsed\n    Given agent output containing {\\\"verdict\\\": \\\"PASS\\\", \\\"issues\\\": []}\n    When gate-check evaluates the output\n    Then the gate passes\n\n  Scenario: Ambiguous text without JSON fails\n    Given agent output \\\"I will pass along these failures\\\"\n    When gate-check evaluates the output\n    Then the gate fails with reason \\\"no structured verdict found\\\"\n\n  Scenario: FAIL verdict with issues\n    Given agent output containing {\\\"verdict\\\": \\\"FAIL\\\", \\\"issues\\\": [\\\"code smell in foo()\\\"]}\n    When gate-check evaluates the output\n    Then the gate fails with reason containing \\\"code smell\\\"\n\\`\\`\\`\n\n## ATDD\n1. All agent-facing gates parse JSON verdict, not substrings\n2. Non-agent gates (tests_pass, tests_fail) retain exit-code based evaluation\n3. Prompt templates include required output schema in instructions\n\n## DBC\n- **Precondition**: Agent prompts include the required JSON verdict schema\n- **Postcondition**: gate-check returns based on parsed verdict field, never substring matching\n- **Invariant**: No gate uses \\`str contains\\` on agent output for pass/fail determination\n\n## Files\n- oc-engine.nu:448-519 (gate-check)\n- oc-tdd15.nu:171-461 (prompt templates need verdict schema appended)","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:23:53.761553002-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.78941542-06:00","dependencies":[{"issue_id":"nuoc-pxx","depends_on_id":"nuoc-3cd","type":"blocks","created_at":"2026-01-28T02:24:58.577260778-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-pxx","depends_on_id":"nuoc-gre","type":"blocks","created_at":"2026-01-28T02:24:58.597302345-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-q3k","title":"[TUI-17] Implement help overlay","description":"## Micro-task\n'?' key shows keyboard shortcut help.\n\n## Acceptance\n- [ ] All shortcuts listed\n- [ ] Any key dismisses\n- [ ] Clear formatting","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:40.566388416-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.047884278-06:00","dependencies":[{"issue_id":"nuoc-q3k","depends_on_id":"nuoc-n5m","type":"blocks","created_at":"2026-01-28T07:07:06.808670378-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-qai","title":"[TUI-16] Implement live database polling","description":"## Micro-task\nPoll database every 500ms for updates.\n\n## Acceptance\n- [ ] Jobs/tasks refresh automatically\n- [ ] Status changes reflected within 1s\n- [ ] No UI flicker","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:38.76242738-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.064864898-06:00","dependencies":[{"issue_id":"nuoc-qai","depends_on_id":"nuoc-b9r","type":"blocks","created_at":"2026-01-28T07:07:06.789061625-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-qgs","title":"[Lifecycle-11] Implement backing-off → running transition","description":"## Micro-task\nRetry scheduler triggers retry.\n\n## Acceptance\n- [ ] next_retry_at reached\n- [ ] Status updated to running\n- [ ] New attempt started","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.62511078-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.435990912-06:00","dependencies":[{"issue_id":"nuoc-qgs","depends_on_id":"nuoc-o6a","type":"blocks","created_at":"2026-01-28T07:07:02.564180214-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-qll","title":"[Ctx-07] Implement ctx.send for async fire-and-forget","description":"## Micro-task\nImplement ctx.send(target, handler, input) for fire-and-forget calls.\n\n## Acceptance\n- [ ] Returns immediately with invocation_id\n- [ ] Target executes asynchronously\n- [ ] Journaled for replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:18.222878253-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.682723419-06:00","dependencies":[{"issue_id":"nuoc-qll","depends_on_id":"nuoc-yd8","type":"blocks","created_at":"2026-01-28T07:06:57.117131832-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-qodw","title":"[Awk-09] Implement awakeable timeout handling","description":"## Micro-task\nFail awakeable if timeout_at passed.\n\n## Acceptance\n- [ ] Scheduler checks timeouts\n- [ ] Status -\u003e TIMEOUT\n- [ ] Task receives timeout error","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.95334105-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.162918499-06:00","dependencies":[{"issue_id":"nuoc-qodw","depends_on_id":"nuoc-szrs","type":"blocks","created_at":"2026-01-28T07:07:04.510969506-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-rbh","title":"[Lifecycle-15] Add state machine validation","description":"## Micro-task\nValidate all state transitions are legal.\n\n## Valid transitions\npending → ready, scheduled\nscheduled → ready\nready → running\nrunning → completed, suspended, backing-off\nsuspended → running\nbacking-off → running, paused, completed\npaused → running\n\n## Acceptance\n- [ ] Invalid transitions rejected\n- [ ] Clear error message\n- [ ] Logged for debugging","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.708511571-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.370505998-06:00","dependencies":[{"issue_id":"nuoc-rbh","depends_on_id":"nuoc-zu2","type":"blocks","created_at":"2026-01-28T07:07:09.554492078-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-rvh","title":"Implement task suspension with resource release — Restate primitive","description":"## KIRK: Key Intent\nReplace polling loops with true suspension. When a task waits for an awakeable, timer, or dependency, it should persist its continuation point, release execution resources (thread/slot), and only resume when the awaited condition is met. Modeled after Restate's aggressive suspension.\n\n## EARS\n- WHEN a task reaches a suspension point (awakeable wait, timer, dependency), THE SYSTEM SHALL persist the suspension state and release the worker slot.\n- WHEN the awaited condition is met, THE SYSTEM SHALL re-enqueue the task for resumption from the suspension point.\n- IF the engine crashes during suspension, THE SYSTEM SHALL restore suspension state from the journal on recovery.\n- WHERE a suspended task has a timeout, THE SYSTEM SHALL fail it if the timeout expires.\n\n## BDD Scenarios\n```gherkin\nFeature: Task suspension\n\n  Scenario: Awakeable suspends and releases slot\n    Given worker W1 has 4/5 slots, task T is running\n    When T calls ctx.awakeable()\n    Then T is suspended, W1 slot count drops to 3/5\n    And T's suspension point is journaled\n\n  Scenario: Timer suspension\n    Given task T calls ctx.sleep(300s)\n    When suspension occurs\n    Then T releases its slot\n    And a timer entry is created with wake_at = now + 300s\n    When timer fires\n    Then T is re-enqueued and resumes from after the sleep\n\n  Scenario: Suspension survives crash\n    Given task T is suspended on awakeable \"awk-123\"\n    And engine crashes and restarts\n    Then T remains in SUSPENDED state\n    When \"awk-123\" is resolved\n    Then T resumes correctly\n```\n\n## ATDD\n1. Suspended tasks consume zero worker slots\n2. Suspension state (point, awaiting, timeout) persisted in journal\n3. Timer-based suspension wakes within 1s of target time\n4. Worker slot count accurate after suspend/resume cycles\n\n## DBC\n- **Precondition**: Task is in RUNNING state when suspension is requested\n- **Postcondition**: Task is in SUSPENDED state, worker slot freed, continuation journaled\n- **Invariant**: A suspended task cannot be claimed by another worker until resumed\n\n## Schema Change\n- Add SUSPENDED to task status enum\n- Add suspension_point, awaiting_type, awaiting_id, wake_at columns to tasks","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:34.969742664-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.079936776-06:00","dependencies":[{"issue_id":"nuoc-rvh","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T02:38:58.307072391-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-rvh","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T02:38:58.481020276-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-s4o","title":"Implement event-driven workflow triggers — Hatchet primitive","description":"## KIRK: Key Intent\nEnable workflows to be triggered by external events (webhooks, file changes, git hooks, cron schedules). Modeled after Hatchet's on_events with wildcard patterns and filtering.\n\n## EARS\n- WHEN an event is published matching a workflow's on_events pattern, THE SYSTEM SHALL create and enqueue a new job for that workflow with the event payload as input.\n- WHERE on_events uses a wildcard pattern (e.g. \"bead:*\"), THE SYSTEM SHALL match all events with that prefix.\n- IF a filter expression is defined, THE SYSTEM SHALL evaluate it against the event payload and only trigger if true.\n- WHEN a cron schedule is defined, THE SYSTEM SHALL trigger the workflow at the specified times (UTC).\n\n## BDD Scenarios\n```gherkin\nFeature: Event-driven triggers\n\n  Scenario: Webhook triggers workflow\n    Given workflow \"deploy\" has on_events=[\"git:push\"]\n    When event \"git:push\" is published with payload {branch: \"main\", sha: \"abc123\"}\n    Then a new job is created for \"deploy\" with that payload as input\n\n  Scenario: Wildcard matching\n    Given workflow \"audit\" has on_events=[\"bead:*\"]\n    When event \"bead:created\" is published\n    Then \"audit\" is triggered\n    When event \"bead:closed\" is published\n    Then \"audit\" is triggered again\n\n  Scenario: Filter rejects event\n    Given workflow \"deploy\" has filter \"input.branch == 'main'\"\n    When event \"git:push\" arrives with {branch: \"feature-x\"}\n    Then no job is created\n\n  Scenario: Cron trigger\n    Given workflow \"nightly-qa\" has cron=\"0 2 * * *\"\n    When the clock reaches 02:00 UTC\n    Then a new job is created for \"nightly-qa\"\n```\n\n## ATDD\n1. Event publish CLI: `oc event publish \u003cname\u003e --payload \u003cjson\u003e`\n2. HTTP endpoint: POST /events with {name, payload}\n3. Wildcard and exact matching both work\n4. Cron scheduler polls at 1-minute resolution\n5. Event log shows all published events and which workflows they triggered\n\n## DBC\n- **Precondition**: Event name is non-empty; workflow with matching on_events exists\n- **Postcondition**: Exactly one job created per (event_id, workflow) match\n- **Invariant**: Events are persisted before triggering (crash-safe)\n\n## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS event_triggers (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  workflow_name TEXT NOT NULL,\n  event_pattern TEXT NOT NULL,\n  filter_expr TEXT,\n  cron_expr TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\nCREATE TABLE IF NOT EXISTS published_events (\n  id TEXT PRIMARY KEY,\n  name TEXT NOT NULL,\n  payload TEXT,\n  published_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n```","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T02:38:40.561572533-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.062464158-06:00","dependencies":[{"issue_id":"nuoc-s4o","depends_on_id":"nuoc-ima","type":"blocks","created_at":"2026-01-28T02:38:58.461978903-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-sad","title":"[HTTP-04] Implement Idempotency-Key header extraction","description":"## Micro-task\nExtract Idempotency-Key header if present.\n\n## Acceptance\n- [ ] Header extracted\n- [ ] Key hashed for lookup\n- [ ] Missing key allowed","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:14.978178524-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.468452965-06:00","dependencies":[{"issue_id":"nuoc-sad","depends_on_id":"nuoc-us9","type":"blocks","created_at":"2026-01-28T07:07:00.888145164-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-svp3","title":"[Worker-09] Implement task re-enqueueing on worker death","description":"## Micro-task\nRe-queue tasks claimed by dead workers.\n\n## Acceptance\n- [ ] Tasks return to QUEUED status\n- [ ] claimed_by cleared\n- [ ] Retry count preserved","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.035175672-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.88331502-06:00","dependencies":[{"issue_id":"nuoc-svp3","depends_on_id":"nuoc-doz1","type":"blocks","created_at":"2026-01-28T07:07:02.68797357-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-syc","title":"[Ctx-05] Implement ctx.stateKeys to list keys","description":"## Micro-task\nImplement ctx.stateKeys() to return all state keys for the object.\n\n## Acceptance\n- [ ] Returns list of key names\n- [ ] Replays from journal\n- [ ] Empty list if no state","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:07.972323575-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.958496816-06:00","dependencies":[{"issue_id":"nuoc-syc","depends_on_id":"nuoc-7mb","type":"blocks","created_at":"2026-01-28T07:06:56.170045268-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-szrs","title":"[Awk-08] Implement task wake on awakeable resolution","description":"## Micro-task\nResume suspended task when awakeable resolved.\n\n## Acceptance\n- [ ] Task status -\u003e ready\n- [ ] Re-enqueued for execution\n- [ ] Resumes from suspension point","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.933523824-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T23:35:50.889424021-06:00","closed_at":"2026-01-28T23:35:50.889424021-06:00","close_reason":"Closed","dependencies":[{"issue_id":"nuoc-szrs","depends_on_id":"nuoc-f2pc","type":"blocks","created_at":"2026-01-28T07:07:04.472843946-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-szrs","depends_on_id":"nuoc-a7ti","type":"blocks","created_at":"2026-01-28T07:07:04.491312843-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-t7r","title":"Implement workflow queries — sync read-only state inspection","description":"## KIRK: Key Intent\nEnable external systems to synchronously query workflow state without affecting execution or creating history entries. Read-only inspection for dashboards, monitoring, and debugging. Modeled after Temporal's queries.\n\n## EARS\n- WHEN a query is sent to a job, THE SYSTEM SHALL execute the query handler and return the result synchronously.\n- WHERE a query handler accesses workflow state, IT SHALL be read-only (no mutations allowed).\n- IF a query is sent to a running workflow, THE SYSTEM SHALL NOT interrupt or affect execution.\n- WHEN a query is sent to a completed workflow, THE SYSTEM SHALL return the final state.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Workflow queries\n\n  Scenario: Query running workflow\n    Given job J is running with state {phase: 5, retries: 2}\n    When query \"get-progress\" is sent\n    Then response is {phase: 5, retries: 2}\n    And no event is recorded in history\n\n  Scenario: Query completed workflow\n    Given job J completed with final state {result: \"success\"}\n    When query \"get-result\" is sent\n    Then response is {result: \"success\"}\n\n  Scenario: Query does not mutate\n    Given query handler attempts to modify state\n    When query is executed\n    Then error is raised \"queries must be read-only\"\n\\`\\`\\`\n\n## ATDD\n1. CLI: \\`oc query \u003cjob_id\u003e \u003cquery_name\u003e\\`\n2. HTTP: GET /jobs/:id/query/:name\n3. Query handlers defined in workflow definition\n4. No events created for queries\n\n## DBC\n- **Precondition**: Query handler exists for the query name\n- **Postcondition**: State unchanged after query\n- **Invariant**: Queries never create journal entries","notes":"## Schema Notes\nQueries are read-only and do NOT create journal entries. No new tables needed.\nQuery handlers are registered in the existing workflow definition structure.\nQuery results are returned synchronously, not persisted.","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:44.163998025-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:58.009909184-06:00","dependencies":[{"issue_id":"nuoc-t7r","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.341979111-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-thz","title":"[Ctx-11] Implement ctx.sleepUntil for timestamp-based sleep","description":"## Micro-task\nImplement ctx.sleepUntil(timestamp) for sleeping until specific time.\n\n## Acceptance\n- [ ] Wakes at or after timestamp\n- [ ] Immediate return if timestamp passed\n- [ ] Journaled for replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:23.011549546-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.583177494-06:00","dependencies":[{"issue_id":"nuoc-thz","depends_on_id":"nuoc-0pi","type":"blocks","created_at":"2026-01-28T07:06:58.53922833-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-tiol","title":"[Worker-07] Implement task completion notification","description":"## Micro-task\nWorker marks task complete and releases slot.\n\n## Acceptance\n- [ ] Task removed from queue\n- [ ] active_slots decremented\n- [ ] Result stored in tasks table","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.991379311-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.918003637-06:00","dependencies":[{"issue_id":"nuoc-tiol","depends_on_id":"nuoc-4w4f","type":"blocks","created_at":"2026-01-28T07:07:02.644720212-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-tvhk","title":"[Worker-04] Implement worker heartbeat","description":"## Micro-task\nUpdate worker's last_heartbeat timestamp.\n\n## Acceptance\n- [ ] Heartbeat updates timestamp\n- [ ] Called periodically (every 10s)\n- [ ] Missing heartbeat = dead worker","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.932558646-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.96757793-06:00","dependencies":[{"issue_id":"nuoc-tvhk","depends_on_id":"nuoc-w3fm","type":"blocks","created_at":"2026-01-28T07:07:02.560893193-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ufl","title":"[Ctx-25] Add context initialization at task start","description":"## Micro-task\nInitialize all context state when task begins execution.\n\n## Deliverable\n- Set $env.JOB_ID, $env.TASK_NAME, $env.ATTEMPT\n- Set $env.OBJECT_KEY if virtual object\n- Set $env.WORKFLOW_ID if workflow\n- Initialize PRNG with random_seed\n\n## Acceptance\n- [ ] All env vars set correctly\n- [ ] Context available to all ctx.* commands\n- [ ] Cleaned up on task end","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:07.79014618-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.974983437-06:00"}
{"id":"nuoc-us9","title":"[HTTP-03] Implement request body parsing","description":"## Micro-task\nParse JSON request body as invocation input.\n\n## Acceptance\n- [ ] JSON parsed\n- [ ] Content-Type validated\n- [ ] Errors return 400","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:13.934340519-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.485808794-06:00","dependencies":[{"issue_id":"nuoc-us9","depends_on_id":"nuoc-o0n","type":"blocks","created_at":"2026-01-28T07:07:00.868501011-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-uuy","title":"[Entity-03] Implement entity lookup by name","description":"## Micro-task\nLook up entity definition by name.\n\n## Acceptance\n- [ ] Returns entity type and handlers\n- [ ] Returns null if not found\n- [ ] Efficient lookup","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:07.195252535-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.007334001-06:00","dependencies":[{"issue_id":"nuoc-uuy","depends_on_id":"nuoc-9kl","type":"blocks","created_at":"2026-01-28T07:06:56.998591324-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-uvi","title":"[Entity-12] Implement shared handler support for virtual objects","description":"## Micro-task\nVirtual objects can have 'shared' handlers that run concurrently (read-only).\n\n## Acceptance\n- [ ] Shared handlers don't acquire lock\n- [ ] Can run while exclusive handler running\n- [ ] Cannot mutate state","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:17.926816871-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.69923724-06:00","dependencies":[{"issue_id":"nuoc-uvi","depends_on_id":"nuoc-eml","type":"blocks","created_at":"2026-01-28T07:07:02.319557986-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-v0g","title":"[Ctx-21] Implement ctx.attach to wait on existing invocation","description":"## Micro-task\nImplement ctx.attach(invocationId) to wait for existing invocation.\n\n## Acceptance\n- [ ] Blocks until invocation completes\n- [ ] Returns invocation result\n- [ ] Journaled","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:02.966425454-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.255776871-06:00"}
{"id":"nuoc-w3fm","title":"[Worker-03] Implement worker registration","description":"## Micro-task\nRegister worker with its queue subscriptions.\n\n## Command\n```nu\nexport def worker-register [id: string, queues: list\u003cstring\u003e, max_slots: int] {\n  sql-exec \"INSERT INTO workers ...\"\n}\n```\n\n## Acceptance\n- [ ] Worker stored in DB\n- [ ] Queues as JSON array\n- [ ] Returns worker ID","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.912091518-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.983661051-06:00","dependencies":[{"issue_id":"nuoc-w3fm","depends_on_id":"nuoc-cetw","type":"blocks","created_at":"2026-01-28T07:07:02.542335987-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-w5m","title":"[Lifecycle-05] Implement pending → scheduled transition","description":"## Micro-task\nHandle delayed invocation creation.\n\n## Acceptance\n- [ ] If delay specified, status = scheduled\n- [ ] scheduled_start_at set correctly\n- [ ] Transitions to ready when time reached","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.504307926-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.533241082-06:00","dependencies":[{"issue_id":"nuoc-w5m","depends_on_id":"nuoc-bjv","type":"blocks","created_at":"2026-01-28T07:07:02.443300192-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-wfd","title":"Implement awakeable ID format — exact Restate encoding","description":"## KIRK: Key Intent\nImplement Restate's exact awakeable ID format so IDs are globally unique, parseable, and can be used by external systems.\n\n## ID Format\n- **Prefix**: \\`prom_1\\`\n- **Encoding**: Base64-URL-Safe (no padding)\n- **Content**: invocation_id + entry_index (u32 big-endian)\n\n## Example\n\\`\\`\\`\ninvocation_id: \"inv_abc123...\"\nentry_index: 4\nawakeable_id: \"prom_1\" + base64url(invocation_id + u32be(4))\nResult: \"prom_1NMyOAvDK2CcBjUH4Rmb7eGBp0DNNDnmsAAAAAQ\"\n\\`\\`\\`\n\n## EARS\n- WHEN ctx.awakeable() is called, THE SYSTEM SHALL generate ID using prefix + base64url(invocation_id + entry_index).\n- WHEN resolving by ID, THE SYSTEM SHALL decode to find invocation and entry.\n- WHERE ID is malformed, THE SYSTEM SHALL return error \"invalid awakeable ID\".\n- IF invocation_id in awakeable doesn't exist, THE SYSTEM SHALL return error \"invocation not found\".\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Awakeable ID format\n\n  Scenario: Generate awakeable ID\n    Given invocation \"inv_xyz\" at entry_index 3\n    When ctx.awakeable() called\n    Then ID starts with \"prom_1\"\n    And decoding reveals invocation=\"inv_xyz\", entry=3\n\n  Scenario: Resolve by ID\n    Given awakeable ID \"prom_1...\"\n    When resolve-awakeable called with ID and payload\n    Then ID decoded to invocation + entry\n    And correct invocation resumed\n\n  Scenario: Invalid ID rejected\n    Given malformed ID \"prom_1!!invalid!!\"\n    When resolve-awakeable called\n    Then error \"invalid awakeable ID\"\n\n  Scenario: Expired invocation\n    Given awakeable ID for completed invocation\n    When resolve-awakeable called\n    Then error \"invocation not found or completed\"\n\\`\\`\\`\n\n## Implementation\n\\`\\`\\`nu\ndef awakeable-id-generate [invocation_id: string, entry_index: int] {\n  let payload = $invocation_id + ($entry_index | into binary | bytes reverse)\n  \"prom_1\" + ($payload | encode base64 --url)\n}\n\ndef awakeable-id-parse [id: string] {\n  if not ($id | str starts-with \"prom_1\") {\n    error make {msg: \"invalid awakeable ID prefix\"}\n  }\n  let payload = ($id | str substring 6.. | decode base64 --url)\n  let entry_bytes = ($payload | bytes last 4 | bytes reverse)\n  let entry_index = ($entry_bytes | into int)\n  let invocation_id = ($payload | bytes first (($payload | bytes length) - 4))\n  {invocation_id: $invocation_id, entry_index: $entry_index}\n}\n\\`\\`\\`\n\n## ATDD\n1. Generated IDs match Restate format exactly\n2. IDs are globally unique (invocation + entry uniqueness)\n3. Parse/generate are inverse operations\n4. Invalid IDs rejected with clear error\n\n## DBC\n- **Precondition**: invocation_id and entry_index valid\n- **Postcondition**: ID uniquely identifies awakeable\n- **Invariant**: Same inputs always produce same ID","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:55.16930166-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.8395794-06:00"}
{"id":"nuoc-wpi9","title":"[Awk-11] Implement awakeable cleanup on job completion","description":"## Micro-task\nMark awakeables cancelled when job completes/cancels.\n\n## Acceptance\n- [ ] All job's awakeables cancelled\n- [ ] Late resolutions rejected\n- [ ] Resources freed","notes":"TDD15 complete - awakeable cleanup on job completion implemented","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:44.991702867-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T01:09:56.18414972-06:00","closed_at":"2026-01-29T01:09:56.18415258-06:00","dependencies":[{"issue_id":"nuoc-wpi9","depends_on_id":"nuoc-szrs","type":"blocks","created_at":"2026-01-28T07:07:04.553133127-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-x7n","title":"Implement workflow updates — sync tracked writes with response","description":"## KIRK: Key Intent\nEnable external systems to send synchronous write requests that modify workflow state and return a response. Unlike signals (fire-and-forget), updates block until processed and return results. Modeled after Temporal's updates.\n\n## EARS\n- WHEN an update is sent to a job, THE SYSTEM SHALL block until the update handler executes and returns a result.\n- WHERE an update modifies state, THE SYSTEM SHALL record it in the journal (unlike queries).\n- IF an update fails, THE SYSTEM SHALL return the error to the caller.\n- WHEN an update is sent to a suspended workflow, THE SYSTEM SHALL wake it to process the update.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Workflow updates\n\n  Scenario: Update modifies state and returns result\n    Given job J with state {count: 5}\n    When update \"increment\" is sent with {by: 3}\n    Then state becomes {count: 8}\n    And response is {new_count: 8}\n    And journal records the update\n\n  Scenario: Update wakes suspended workflow\n    Given job J is suspended\n    When update \"set-priority\" is sent\n    Then J wakes, processes update, returns result\n    Then J re-suspends if still waiting\n\n  Scenario: Update failure returns error\n    Given update handler throws error \"invalid input\"\n    When update is sent\n    Then caller receives error \"invalid input\"\n\\`\\`\\`\n\n## ATDD\n1. CLI: \\`oc update \u003cjob_id\u003e \u003cupdate_name\u003e --payload \u003cjson\u003e\\`\n2. HTTP: POST /jobs/:id/update/:name\n3. Updates recorded in journal\n4. Timeout for update response (default 30s)\n\n## DBC\n- **Precondition**: Update handler exists for the update name\n- **Postcondition**: State mutation journaled, response returned\n- **Invariant**: Updates are exactly-once via idempotency key","notes":"## Schema Addition\n```sql\nCREATE TABLE IF NOT EXISTS updates (\n  id TEXT PRIMARY KEY,\n  job_id TEXT NOT NULL,\n  update_name TEXT NOT NULL,\n  payload TEXT,\n  status TEXT NOT NULL DEFAULT 'PENDING',\n  result TEXT,\n  error TEXT,\n  timeout_at TEXT,\n  created_at TEXT NOT NULL DEFAULT (datetime('now')),\n  completed_at TEXT\n);\nCREATE INDEX idx_update_job ON updates(job_id, status);\n\n-- Update handlers registered per workflow\nCREATE TABLE IF NOT EXISTS update_handlers (\n  workflow_name TEXT NOT NULL,\n  update_name TEXT NOT NULL,\n  handler_task TEXT NOT NULL,\n  PRIMARY KEY (workflow_name, update_name)\n);\n```","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:46.702535965-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.941883016-06:00","dependencies":[{"issue_id":"nuoc-x7n","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.323144941-06:00","created_by":"Lewis Prior"},{"issue_id":"nuoc-x7n","depends_on_id":"nuoc-n8o","type":"blocks","created_at":"2026-01-28T06:34:09.569611702-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-xgo","title":"[Replay-06] Implement replay-mode flag in task context","description":"## Micro-task\nTrack whether task is in replay mode (reading from journal) or live mode (writing new entries).\n\n## Deliverable\n- \\$env.REPLAY_MODE boolean\n- Transitions from replay to live when entry_index \u003e known_entries\n- known_entries from StartMessage equivalent\n\n## Acceptance\n- [ ] REPLAY_MODE=true when entry_index \u003c known_entries\n- [ ] REPLAY_MODE=false when entry_index \u003e= known_entries\n- [ ] Transitions correctly mid-execution","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:07.596391368-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.99077393-06:00","dependencies":[{"issue_id":"nuoc-xgo","depends_on_id":"nuoc-aa6","type":"blocks","created_at":"2026-01-28T07:06:54.009076784-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-xm7h","title":"[Awk-12] Implement ctx.rejectAwakeable","description":"## Micro-task\nReject awakeable with error instead of value.\n\n## Acceptance\n- [ ] Status -\u003e REJECTED\n- [ ] Error stored\n- [ ] Task receives error","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.011610802-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T01:24:33.517152489-06:00","closed_at":"2026-01-29T01:24:33.517152489-06:00","close_reason":"TDD15 + Red Queen complete - battle-hardened reject-awakeable implementation","dependencies":[{"issue_id":"nuoc-xm7h","depends_on_id":"nuoc-a7ti","type":"blocks","created_at":"2026-01-28T07:07:04.573469452-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-xma","title":"[TUI-03] Implement App state struct","description":"## Micro-task\nCreate App struct holding UI state.\n\n## Fields\n- jobs: Vec\u003cJob\u003e\n- selected_job_index: usize\n- current_view: View enum\n- db_connection: Connection\n\n## Acceptance\n- [ ] App struct defined\n- [ ] View enum (JobList, DAG, Events, Metrics)\n- [ ] State updates work","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:04:20.849054893-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.335534442-06:00","dependencies":[{"issue_id":"nuoc-xma","depends_on_id":"nuoc-gby","type":"blocks","created_at":"2026-01-28T07:07:06.509847571-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-xn7","title":"[Ctx-04] Implement ctx.clearAll for full state wipe","description":"## Micro-task\nImplement ctx.clearAll() to delete all state for the object.\n\n## Acceptance\n- [ ] All keys for object_key removed\n- [ ] Operation journaled\n- [ ] Idempotent on replay","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:06.31473501-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.054765538-06:00","dependencies":[{"issue_id":"nuoc-xn7","depends_on_id":"nuoc-ltc","type":"blocks","created_at":"2026-01-28T07:06:56.150242887-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-xtp","title":"[Replay-04] Implement check-replay to detect if entry exists","description":"## Micro-task\nCheck if a journal entry exists for given (job_id, task_name, attempt, entry_index).\n\n## Deliverable\n\\`\\`\\`nu\nexport def check-replay [\n  job_id: string,\n  task_name: string,\n  attempt: int,\n  entry_index: int\n]: nothing -\u003e record | null {\n  let result = (sql \\$\"SELECT output FROM journal WHERE ...\")\n  if (\\$result | is-empty) { null } else { \\$result.0.output | from json }\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Returns cached output if exists\n- [ ] Returns null if not exists\n- [ ] Output deserialized from JSON","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:04.695062637-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:03:18.55871475-06:00","closed_at":"2026-01-29T05:03:18.5587171-06:00","dependencies":[{"issue_id":"nuoc-xtp","depends_on_id":"nuoc-2d6","type":"blocks","created_at":"2026-01-28T07:06:53.96807989-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-y4i","title":"[Replay-14] Implement journal compaction for completed tasks","description":"## Micro-task\nAfter task completes successfully, compact journal to single summary entry (optional optimization).\n\n## Acceptance\n- [ ] Journal entries can be compacted\n- [ ] Full journal retained for configured duration\n- [ ] Compaction doesn't affect running tasks","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:06.626444957-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.038904836-06:00","dependencies":[{"issue_id":"nuoc-y4i","depends_on_id":"nuoc-j8c","type":"blocks","created_at":"2026-01-28T07:06:54.170919547-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-ycl0","title":"[Worker-10] Implement queue depth monitoring","description":"## Micro-task\nQuery for queue depth per queue name.\n\n## Acceptance\n- [ ] Count of QUEUED tasks per queue\n- [ ] Available in status output\n- [ ] Used for backpressure decisions","status":"open","priority":1,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:05:45.055948706-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.867301578-06:00","dependencies":[{"issue_id":"nuoc-ycl0","depends_on_id":"nuoc-m5uj","type":"blocks","created_at":"2026-01-28T07:07:02.709963195-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-yd8","title":"[Ctx-06] Implement ctx.call for sync invocation","description":"## Micro-task\nImplement ctx.call(target, handler, input) for synchronous service calls.\n\n## Deliverable\n\\`\\`\\`nu\nexport def \"ctx call\" [target: string, handler: string, input: any] {\n  let idx = (next-entry-index)\n  if $env.REPLAY_MODE and $idx \u003c $env.KNOWN_ENTRIES {\n    return (check-replay ... $idx)\n  }\n  # Create invocation, wait for completion\n  let inv_id = (create-invocation $target $handler $input)\n  let result = (wait-invocation $inv_id)\n  journal-write ... $idx \"call\" {target: $target, handler: $handler, input: $input} $result\n  $result\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Blocks until target completes\n- [ ] Returns target's result\n- [ ] Replays from journal","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:09.768290202-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.861337986-06:00","dependencies":[{"issue_id":"nuoc-yd8","depends_on_id":"nuoc-zno","type":"blocks","created_at":"2026-01-28T07:06:57.094005441-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-zdv","title":"[Replay-18] Add concurrent replay prevention (job locking)","description":"## Micro-task\nPrevent multiple processes from replaying same job simultaneously.\n\n## Deliverable\n- Lock acquisition before replay\n- Lock release on completion\n- Error if lock held by another\n\n## Acceptance\n- [ ] Only one replay per job at a time\n- [ ] Lock timeout for stuck processes\n- [ ] Clear error message on lock conflict","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:12.575302639-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:55.796775159-06:00","dependencies":[{"issue_id":"nuoc-zdv","depends_on_id":"nuoc-bsx","type":"blocks","created_at":"2026-01-28T07:06:54.249703974-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-zgi","title":"Implement durable promises — ctx.promise, ctx.peek, ctx.complete","description":"## KIRK: Key Intent\nImplement Restate's durable promises for workflows. Unlike awakeables (external resolution), promises are workflow-internal coordination primitives. Multiple handlers can await the same promise.\n\n## Promise API\n- **ctx.promise(key)**: Get or create promise by key, returns awaitable\n- **ctx.peek(key)**: Non-blocking check, returns value or undefined\n- **ctx.complete(key, value)**: Resolve promise, wake all waiters\n\n## Semantics\n- Promises are keyed per workflow instance\n- Multiple handlers can await same promise\n- Resolution is durable (survives crash)\n- Peek is non-blocking read\n\n## EARS\n- WHEN ctx.promise(key) is called, THE SYSTEM SHALL return a promise that resolves when key is completed.\n- WHEN ctx.peek(key) is called, THE SYSTEM SHALL return current value or undefined without blocking.\n- WHEN ctx.complete(key, value) is called, THE SYSTEM SHALL resolve the promise and wake all waiters.\n- IF promise is already completed, ctx.promise(key) SHALL return immediately with value.\n- WHERE multiple handlers await same promise, ALL SHALL be woken on completion.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Durable promises\n\n  Scenario: Promise await and complete\n    Given workflow handler H1 calls ctx.promise(\"approval\")\n    And H1 suspends waiting for promise\n    When handler H2 calls ctx.complete(\"approval\", {approved: true})\n    Then H1 resumes with {approved: true}\n\n  Scenario: Peek non-blocking\n    Given promise \"status\" not yet completed\n    When ctx.peek(\"status\") called\n    Then returns undefined immediately\n    When promise completed with \"done\"\n    And ctx.peek(\"status\") called\n    Then returns \"done\"\n\n  Scenario: Promise survives crash\n    Given handler awaiting promise \"result\"\n    And engine crashes\n    When engine restarts\n    And ctx.complete(\"result\", 42) called\n    Then original handler resumes with 42\n\n  Scenario: Multiple waiters\n    Given handlers H1, H2, H3 all await promise \"signal\"\n    When ctx.complete(\"signal\", \"go\")\n    Then H1, H2, H3 all resume with \"go\"\n\\`\\`\\`\n\n## Schema\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS workflow_promises (\n  workflow_name TEXT NOT NULL,\n  workflow_id TEXT NOT NULL,\n  promise_key TEXT NOT NULL,\n  status TEXT NOT NULL DEFAULT 'pending',\n  value TEXT,\n  completed_at TEXT,\n  PRIMARY KEY (workflow_name, workflow_id, promise_key)\n);\n\nCREATE TABLE IF NOT EXISTS promise_waiters (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  workflow_name TEXT NOT NULL,\n  workflow_id TEXT NOT NULL,\n  promise_key TEXT NOT NULL,\n  invocation_id TEXT NOT NULL,\n  entry_index INTEGER NOT NULL,\n  created_at TEXT NOT NULL DEFAULT (datetime('now'))\n);\n\\`\\`\\`\n\n## ATDD\n1. ctx.promise() blocks until completed\n2. ctx.peek() never blocks\n3. ctx.complete() wakes all waiters\n4. Promises scoped to workflow instance\n\n## DBC\n- **Precondition**: Called within workflow context\n- **Postcondition**: Promise state persisted\n- **Invariant**: Promise completed at most once per key","status":"open","priority":1,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:58:52.206753557-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.585846165-06:00"}
{"id":"nuoc-zno","title":"[Replay-08] Implement replay logic in ctx.run","description":"## Micro-task\nctx.run checks replay mode. If replaying, return cached output. If live, execute and journal.\n\n## Deliverable\n\\`\\`\\`nu\nexport def \"ctx run\" [closure: closure] {\n  let idx = (next-entry-index)\n  if \\$env.REPLAY_MODE and \\$idx \u003c \\$env.KNOWN_ENTRIES {\n    return (check-replay \\$env.JOB_ID \\$env.TASK_NAME \\$env.ATTEMPT \\$idx)\n  }\n  let result = (do \\$closure)\n  journal-write \\$env.JOB_ID \\$env.TASK_NAME \\$env.ATTEMPT \\$idx \"run\" {} \\$result\n  \\$result\n}\n\\`\\`\\`\n\n## Acceptance\n- [ ] Replays return cached output\n- [ ] Live executes closure\n- [ ] Result journaled on live","status":"closed","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:09.974084797-06:00","created_by":"Lewis Prior","updated_at":"2026-01-29T05:08:45.245591599-06:00","closed_at":"2026-01-29T05:08:45.245591599-06:00","close_reason":"Closed","dependencies":[{"issue_id":"nuoc-zno","depends_on_id":"nuoc-bsx","type":"blocks","created_at":"2026-01-28T07:06:54.047923004-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-znx","title":"Implement workflow search attributes and visibility queries","description":"## KIRK: Key Intent\nEnable indexing and searching workflows by custom attributes (status, type, owner, tags, etc.). Powers dashboards, debugging, and operational queries. Modeled after Temporal's search attributes and visibility.\n\n## EARS\n- WHEN a workflow sets a search attribute, THE SYSTEM SHALL index it for querying.\n- WHERE a visibility query is issued, THE SYSTEM SHALL return matching jobs efficiently via indexed lookup.\n- IF search attributes are updated during execution, THE SYSTEM SHALL update the index.\n- WHEN standard attributes (status, type, start_time) are used, THE SYSTEM SHALL provide built-in indexes.\n\n## BDD Scenarios\n\\`\\`\\`gherkin\nFeature: Search and visibility\n\n  Scenario: Search by custom attribute\n    Given job J1 has search_attr {owner: \"alice\", priority: \"high\"}\n    And job J2 has search_attr {owner: \"bob\", priority: \"low\"}\n    When searching owner=\"alice\"\n    Then J1 is returned, not J2\n\n  Scenario: Search by status\n    Given 10 COMPLETED and 5 RUNNING jobs\n    When searching status=\"RUNNING\"\n    Then 5 jobs returned\n\n  Scenario: Compound query\n    Given jobs with various attributes\n    When searching owner=\"alice\" AND priority=\"high\" AND status=\"FAILED\"\n    Then matching jobs returned\n\\`\\`\\`\n\n## ATDD\n1. ctx.set_search_attribute(name, value) API\n2. CLI: \\`oc job list --query 'owner=\"alice\"'\\`\n3. HTTP: GET /jobs?query=...\n4. Standard attributes indexed by default\n\n## DBC\n- **Precondition**: Search attribute name is registered in schema\n- **Postcondition**: Indexed value matches current job state\n- **Invariant**: Search results consistent with job state\n\n## Schema Addition\n\\`\\`\\`sql\nCREATE TABLE IF NOT EXISTS search_attributes (\n  job_id TEXT NOT NULL,\n  name TEXT NOT NULL,\n  value TEXT,\n  value_type TEXT DEFAULT 'string',\n  PRIMARY KEY (job_id, name)\n);\nCREATE INDEX idx_search_attr_value ON search_attributes(name, value);\n\\`\\`\\`","status":"open","priority":2,"issue_type":"feature","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T06:33:47.507683148-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:57.88962672-06:00","dependencies":[{"issue_id":"nuoc-znx","depends_on_id":"nuoc-577","type":"blocks","created_at":"2026-01-28T06:34:09.359660541-06:00","created_by":"Lewis Prior"}]}
{"id":"nuoc-zu2","title":"[Lifecycle-14] Implement running → completed transition","description":"## Micro-task\nHandler completes (success or non-retriable failure).\n\n## Acceptance\n- [ ] Status updated to completed\n- [ ] completed_at timestamp set\n- [ ] completion_result set","status":"open","priority":0,"issue_type":"task","owner":"priorlewis43@gmail.com","created_at":"2026-01-28T07:02:00.686338826-06:00","created_by":"Lewis Prior","updated_at":"2026-01-28T21:46:56.387659967-06:00","dependencies":[{"issue_id":"nuoc-zu2","depends_on_id":"nuoc-lz7","type":"blocks","created_at":"2026-01-28T07:07:09.53280659-06:00","created_by":"Lewis Prior"}]}
